// Header file for elements that are used to integrate fluid tractions
// This includes the guts (i.e. equations) because we want to inline them
// for faster operation, although it slows down the compilation!

#ifndef OOMPH_NAVIER_STOKES_FACE_ELEMENTS_HEADER
#define OOMPH_NAVIER_STOKES_FACE_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// OOMPH-LIB headers
#include "../generic/elements.h"
#include "navier_stokes_elements.h"

namespace oomph
{
  //======================================================================
  /// A class for elements that allow the imposition of an applied traction
  /// to the Navier--Stokes equations
  /// The geometrical information can be read from the
  /// FaceGeometry<NavierStokesEquationNumberingElement> class and and thus, we
  /// can be generic enough without the need to have a separate equations class
  //======================================================================
  class NavierStokesFaceElement : public virtual FaceElement
  {
  public:
    NavierStokesFaceElement() {}

    virtual inline unsigned nst_u_index(const unsigned& n,
                                        const unsigned& i) const
    {
      NavierStokesEquationNumberingElement* el_pt =
        dynamic_cast<NavierStokesEquationNumberingElement*>(
          this->bulk_element_pt());
      return el_pt->u_index_nst(this->bulk_node_number(n), i);
    }

    // virtual int nst_p_index() const
    virtual int nst_p_index(const unsigned& n) const
    {
      NavierStokesEquationNumberingElement* el_pt =
        dynamic_cast<NavierStokesEquationNumberingElement*>(
          this->bulk_element_pt());
      // return el_pt->p_index_nst(this->bulk_node_number(n));
      return el_pt->p_index_nst();
    }

    virtual inline unsigned nst_momentum_index(const unsigned& n,
                                               const unsigned& i) const
    {
      NavierStokesEquationNumberingElement* el_pt =
        dynamic_cast<NavierStokesEquationNumberingElement*>(
          this->bulk_element_pt());
      return el_pt->momentum_index_nst(this->bulk_node_number(n), i);
    }

    virtual inline unsigned nst_continuity_index(const unsigned& n) const
    {
      const int nodal_index = nst_p_index(n);
      return this->nodal_local_eqn(n, nodal_index);
    }


    virtual double nst_u(const unsigned& n, const unsigned& i) const
    {
      const unsigned nodal_index = nst_u_index(n, i);
      return this->nodal_value(n, nodal_index);
    }

    virtual inline unsigned nst_u_local_unknown(const unsigned& n,
                                                const unsigned& i) const
    {
      const unsigned nodal_index = nst_u_index(n, i);
      return this->nodal_local_eqn(n, nodal_index);
    }

    virtual inline unsigned nst_momentum_local_eqn(const unsigned& n,
                                                   const unsigned& i) const
    {
      const unsigned nodal_index = nst_momentum_index(n, i);
      return this->nodal_local_eqn(n, nodal_index);
    }

    virtual inline unsigned nst_continuity_local_eqn(const unsigned& n) const
    {
      const unsigned nodal_index = nst_continuity_index(n);
      return this->nodal_local_eqn(n, nodal_index);
    }

    double interpolated_u(const Vector<double>& s, const unsigned& i) const
    {
      // Local coordinates in bulk element
      Vector<double> s_bulk(dim() + 1);
      s_bulk = local_coordinate_in_bulk(s);

      // Get Eulerian position vector
      return dynamic_cast<NavierStokesEquationNumberingElement*>(
               bulk_element_pt())
        ->interpolated_u_nst(s_bulk, i);
    }

    virtual double interpolated_p(const Vector<double>& s) const
    {
      return 0;
    }
  };

} // namespace oomph

#endif
