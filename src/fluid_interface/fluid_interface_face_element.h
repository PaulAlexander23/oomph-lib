// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2024 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Header file for (one-dimensional) free surface elements
// Include guards, to prevent multiple includes
#ifndef OOMPH_FLUID_INTERFACE_FACE_ELEMENT_HEADER
#define OOMPH_FLUID_INTERFACE_FACE_ELEMENT_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

#include "../generic/elements.h"
#include "../generic/spines.h"
#include "../generic/shape.h"
#include "../generic/hijacked_elements.h"
#include "../navier_stokes/navier_stokes_face_elements.h"
#include "interface_elements.h"

namespace oomph
{
  //======================================================================
  /// A class for elements that allow the imposition of an applied traction
  /// to the Navier--Stokes equations
  /// The geometrical information can be read from the
  /// FaceGeometry<NavierStokesEquationNumberingElement> class and and thus, we
  /// can be generic enough without the need to have a separate equations class
  //======================================================================
  class FluidInterfaceFaceElement : public virtual FaceElement
  {
  private:
    /// Index at which the i-th velocity component is stored in the
    /// element's nodes
    Vector<unsigned> U_index_interface_boundary;

  public:
    FluidInterfaceFaceElement() {}

    /// Access for nodal index at which the velocity components are stored
    Vector<unsigned>& u_index_interface_boundary()
    {
      return U_index_interface_boundary;
    }

    virtual inline unsigned u_index_nst(const unsigned& n,
                                        const unsigned& i) const
    {
      // NavierStokesFaceElement* el_pt =
      //   dynamic_cast<NavierStokesFaceElement*>(this->bulk_element_pt());
      // return el_pt->u_index_nst(this->bulk_node_number(n), i);
      return U_index_interface_boundary[i];
    }

    virtual int p_nodal_index_nst(const unsigned& n) const
    {
      NavierStokesFaceElement* el_pt =
        dynamic_cast<NavierStokesFaceElement*>(this->bulk_element_pt());
      return el_pt->p_nodal_index_nst(this->bulk_node_number(n));
    }

    virtual inline unsigned momentum_index_nst(const unsigned& n,
                                               const unsigned& i) const
    {
      // NavierStokesFaceElement* el_pt =
      //   dynamic_cast<NavierStokesFaceElement*>(this->bulk_element_pt());
      // return el_pt->momentum_index_nst(this->bulk_node_number(n), i);
      return U_index_interface_boundary[i];
    }

    virtual inline unsigned nst_continuity_index(const unsigned& n) const
    {
      const int nodal_index = p_nodal_index_nst(n);
      return nodal_index;
    }

    virtual double nst_u(const unsigned& n, const unsigned& i) const
    {
      const unsigned nodal_index = u_index_nst(n, i);
      return this->nodal_value(n, nodal_index);
    }

    virtual inline int nst_u_local_unknown(const unsigned& n,
                                           const unsigned& i) const
    {
      const unsigned nodal_index = u_index_nst(n, i);
      return this->nodal_local_eqn(n, nodal_index);
    }

    virtual inline int nst_momentum_local_eqn(const unsigned& n,
                                              const unsigned& i) const
    {
      const unsigned nodal_index = momentum_index_nst(n, i);
      return this->nodal_local_eqn(n, nodal_index);
    }
  };

} // namespace oomph
#endif
