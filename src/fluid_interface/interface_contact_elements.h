// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2024 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Header file for (one-dimensional) free surface elements
// Include guards, to prevent multiple includes
#ifndef OOMPH_INTERFACE_CONTACT_ELEMENTS_HEADER
#define OOMPH_INTERFACE_CONTACT_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

#include "../generic/elements.h"
#include "../generic/spines.h"
#include "../generic/shape.h"
#include "../generic/hijacked_elements.h"
#include "../navier_stokes/navier_stokes_face_elements.h"
#include "interface_elements.h"
#include "fluid_interface_face_element.h"

namespace oomph
{
  //========================================================================
  /// Base class for elements at the boundary of free surfaces or interfaces,
  /// used typically to impose contact angle boundary conditions.
  /// The elemental dimensions are one less than those of the
  /// surface elements, or two less than those of the original bulk elements.
  /// Thus in two-dimensional and axi-symmetric problems, are points,
  /// but in three-dimensional problems, they are lines.
  /// These boundaries may be in contact with a solid surface, in which case
  /// the normal to that surface must be provided.
  //=========================================================================
  // template<class DERIVATIVE_CLASS>
  class ContactLineElement : public virtual FluidInterfaceFaceElement
  {
  private:
    /// Function pointer to a wall unit normal function. Returns the
    /// unit normal on the wall, at the specified Eulerian coordinate.
    typedef void (*WallUnitNormalFctPt)(const Vector<double>& x,
                                        Vector<double>& unit_normal);

    /// Function pointer to a contact angle function. Returns the
    /// contact angle between the fluid and the wall, for a given contact line
    /// velocity
    typedef double (*ContactAngleFctPt)(const Vector<double>& x,
                                        const Vector<double>& local_u);

    enum
    {
      STRONG,
      WEAK
    };

    /// Pointer to a wall normal function that returns
    /// the wall unit normal as a function of position in global
    /// Eulerian coordinates.
    WallUnitNormalFctPt Wall_unit_normal_fct_pt;

    /// Pointer to a contact angle function that returns
    /// the contact angle as a function of the contact line velocity.
    ContactAngleFctPt Contact_angle_fct_pt;

    /// Pointer to the desired value of the capillary number
    double* Ca_pt;

    /// Pointer to the desired value of the "sigma" number
    double* Sigma_pt;

    /// Pointer to the desired value of the Strouhal number
    double* St_pt;

  protected:
    /// Flag used to determine whether the contact angle is to be
    /// used (0 if not), and whether it will be applied weakly as a force term
    /// in the momentum equations (1) or by hijacking the kinematic
    /// condition (2).
    Vector<unsigned> Contact_angle_flag;

    /// Flag used to determine whether the contact angle is to be
    /// set by the fixed value (0) or by the function (1) (Default).
    unsigned Contact_angle_fct_flag;


  public:
    ContactLineElement()
      : Wall_unit_normal_fct_pt(0),
        Contact_angle_fct_pt(0),
        Ca_pt(0),
        Sigma_pt(0),
        St_pt(0)
    {
    }

    void build(FiniteElement* const& element_pt,
               const int& face_index,
               const unsigned& id = 0)
    {
      // FluidInterfaceFaceElement::build(element_pt, face_index, id);

      Contact_angle_flag = Vector<unsigned>(nnode(), WEAK);

      std::cout << "x: " << this->node_pt(0)->position(0) << ", ";
      std::cout << "y: " << this->node_pt(0)->position(1) << ", ";
      std::cout << std::endl;

      add_internal_data(new Data(1));
    }

    /// "Constructor" takes a "bulk" element, the
    /// index that identifies which face the
    /// ImposeImpenetrabilityElement is supposed
    /// to be attached to, and the face element ID
    // virtual void set_n_additional_values()
    // {
    //   for (unsigned n = 0; n < this->nnode(); n++)
    //   {
    //     this->N_additional_values[n] += 1;
    //   }
    // }

    // /// Fill in the specific surface derivative calculations
    // /// by calling the appropriate function from the derivative class
    // double compute_surface_derivatives(
    //   const Shape& psi,
    //   const DShape& dpsids,
    //   const DenseMatrix<double>& interpolated_t,
    //   const Vector<double>& interpolated_x,
    //   DShape& surface_gradient,
    //   DShape& surface_divergence)
    // {
    //   return DERIVATIVE_CLASS::compute_surface_derivatives(psi,
    //                                                        dpsids,
    //                                                        interpolated_t,
    //                                                        interpolated_x,
    //                                                        surface_gradient,
    //                                                        surface_divergence);
    // }

    /// Function that returns the unit normal of the bounding wall
    /// directed out of the fluid
    void wall_unit_normal(const Vector<double>& x, Vector<double>& normal)
    {
#ifdef PARANOID
      if (Wall_unit_normal_fct_pt)
      {
#endif
        (*Wall_unit_normal_fct_pt)(x, normal);
#ifdef PARANOID
      }
      else
      {
        throw OomphLibError("Wall unit normal fct has not been set",
                            "ContactLineElement::wall_unit_normal()",
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif
    }

  protected:
    // /// The geometric data of the parent element is included as
    // /// external data and so a (bulk) node update must take place after
    // /// the variation of any of this external data
    // inline void update_in_external_fd(const unsigned& i)
    // {
    //   // Update the bulk element
    //   bulk_element_pt()->node_update();
    // }

    // /// The only external data are these geometric data so
    // /// We can omit the reset function (relying on the next update
    // // function to take care of the remesh)
    // inline void reset_in_external_fd(const unsigned& i) {}

    // /// We require a final node update in the bulk element
    // /// after all finite differencing
    // inline void reset_after_external_fd()
    // {
    //   // Update the bulk element
    //   bulk_element_pt()->node_update();
    // }

  public:
    /// Access function: Pointer to wall unit normal function
    WallUnitNormalFctPt& wall_unit_normal_fct_pt()
    {
      return Wall_unit_normal_fct_pt;
    }

    /// Access function: Pointer to wall unit normal function. Const version
    WallUnitNormalFctPt wall_unit_normal_fct_pt() const
    {
      return Wall_unit_normal_fct_pt;
    }

    // Get the contact angle from the double pointer or function pointer
    double get_contact_angle(const Vector<double>& x,
                             const Vector<double>& local_u)
    {
#ifdef PARANOID
      if (Contact_angle_fct_pt == 0)
      {
        std::ostringstream error_message;
        error_message << "The contact angle function has not been set."
                      << std::endl;
        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif

      return (*Contact_angle_fct_pt)(x, local_u);
    }

    void set_contact_angle_fct(const ContactAngleFctPt& contact_angle_fct_pt)
    {
      Contact_angle_fct_pt = contact_angle_fct_pt;
    }

    void set_strong_imposition(const unsigned& n)
    {
      // Hijack the bulk element residuals
      // dynamic_cast<ELEMENT*>(bulk_element_pt())
      //   ->hijack_kinematic_conditions(this->bulk_node_number(n));

      // this->fix_lagrange_multiplier(n);

      Contact_angle_flag[n] = STRONG;
    }

    void set_weak_imposition(const unsigned& n)
    {
      // std::cout << "here" << std::endl;
      // std::string error_message =
      //   "unhijack_kinematic_conditions not implemented.";
      // throw OomphLibError(
      //   error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
      // Un-hijack the bulk element residuals

      // dynamic_cast<ELEMENT*>(bulk_element_pt())
      //   ->unhijack_kinematic_conditions(this->bulk_node_number(n));

      // this->free_lagrange_multiplier(n);

      Contact_angle_flag[n] = WEAK;
    }

    /// Access function to the pointer specifying the capillary number
    double*& ca_pt()
    {
      return Ca_pt;
    }

    /// Return the value of the capillary number
    double ca()
    {
#ifdef PARANOID
      if (Ca_pt != 0)
      {
#endif
        return *Ca_pt;
#ifdef PARANOID
      }
      else
      {
        throw OomphLibError("Capillary number has not been set",
                            "ContactLineElement::ca()",
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif
    }

    /// Access function to the pointer specifying the capillary number
    double*& sigma_pt()
    {
      return Sigma_pt;
    }

    /// Return the value of the capillary number
    double sigma()
    {
#ifdef PARANOID
      if (Sigma_pt != 0)
      {
#endif
        return *Sigma_pt;
#ifdef PARANOID
      }
      else
      {
        throw OomphLibError("Capillary number has not been set",
                            "ContactLineElement::ca()",
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif
    }

    /// Access function to the pointer specifying the capillary number
    double*& st_pt()
    {
      return St_pt;
    }

    /// Return the value of the capillary number
    double st()
    {
#ifdef PARANOID
      if (St_pt != 0)
      {
#endif
        return *St_pt;
#ifdef PARANOID
      }
      else
      {
        throw OomphLibError("Capillary number has not been set",
                            "ContactLineElement::ca()",
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif
    }

    //--------------------------------------------------------------------------

    virtual const unsigned fsi_lagrange_multiplier_nodal_index(
      const unsigned& n) = 0;

    virtual int fsi_kinematic_local_eqn(const unsigned& n)
    {
      const unsigned nodal_index = fsi_lagrange_multiplier_nodal_index(n);
      return this->nodal_local_eqn(n, nodal_index);
    }

    virtual double fsi_lagrange_multiplier(const unsigned& n)
    {
      const unsigned nodal_index = fsi_lagrange_multiplier_nodal_index(n);
      return this->nodal_value(n, nodal_index);
    }

    //--------------------------------------------------------------------------

    // const unsigned cl_lagrange_multiplier_nodal_index(const unsigned& n)
    // {
    // return this->additional_value_index(n, 0);
    // }

    virtual int wall_bounded_kinematic_local_eqn(const unsigned& n)
    {
      // const unsigned nodal_index = cl_lagrange_multiplier_nodal_index(n);
      // return this->nodal_local_eqn(n, nodal_index);
      return internal_local_eqn(0, n);
    }

    virtual double cl_lagrange_multiplier(const unsigned& n)
    {
      // const unsigned nodal_index = cl_lagrange_multiplier_nodal_index(n);
      // return this->nodal_value(n, nodal_index);
      return internal_data_pt(0)->value(n);
    }

    void fix_lagrange_multiplier(const unsigned& n, const double& value)
    {
      // this->node_pt(n)->pin(cl_lagrange_multiplier_nodal_index(n));
      // this->node_pt(n)->set_value(cl_lagrange_multiplier_nodal_index(n),
      // value);
      internal_data_pt(0)->pin(n);
      internal_data_pt(0)->set_value(n, value);
    }

    void free_lagrange_multiplier(const unsigned& n)
    {
      // this->node_pt(n)->unpin(cl_lagrange_multiplier_nodal_index(n));
      internal_data_pt(0)->unpin(n);
    }

    //--------------------------------------------------------------------------

    /// Calculate the residuals
    void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      // Add the residual contributions using a dummy matrix
      fill_in_generic_residual_contribution_interface_boundary(
        residuals, GeneralisedElement::Dummy_matrix, 0);
    }

    /// Calculate the generic residuals contribution
    virtual void fill_in_generic_residual_contribution_interface_boundary(
      Vector<double>& residuals, DenseMatrix<double>& jacobian, unsigned flag);


    /// Empty helper function to calculate the additional contributions
    /// arising from the node update strategy to the Jacobian within the
    /// integration loop. This will be overloaded by elements that require
    /// contributions to their underlying equations from boundary integrals.
    /// The shape functions, their derivatives w.r.t. to the local coordinates,
    /// the unit normal and integral weight are passed in so that they do not
    /// have to be recalculated.
    virtual void add_additional_residual_contributions_interface_boundary(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      const unsigned& flag,
      const Shape& psif,
      const DShape& dpsifds,
      const Vector<double>& interpolated_n,
      const double& W)
    {
    }

    /// Overload the output function
    void output(std::ostream& outfile)
    {
      FiniteElement::output(outfile);
    }

    /// Output function
    void output(std::ostream& outfile, const unsigned& n_plot)
    {
      FiniteElement::output(outfile, n_plot);
    }

    /// Overload the C-style output function
    void output(FILE* file_pt)
    {
      FiniteElement::output(file_pt);
    }

    /// C-style Output function
    void output(FILE* file_pt, const unsigned& n_plot)
    {
      FiniteElement::output(file_pt, n_plot);
    }
  };


  // //==========================================================================
  // /// Specialisation of the interface boundary constraint to a point
  // //==========================================================================
  // class PointFluidInterfaceBoundingElement : public ContactLineElement
  // {
  // protected:
  //   /// Overload the helper function to calculate the residuals and
  //   /// (if flag==1) the Jacobian -- this function only deals with
  //   /// the part of the Jacobian that can be handled generically.
  //   /// Specific additional contributions may be provided in
  //   /// add_additional_residual_contributions_interface_boundary(...)
  //   void fill_in_generic_residual_contribution_interface_boundary(
  //     Vector<double>& residuals, DenseMatrix<double>& jacobian, unsigned
  //     flag);

  //   // Index to the Kinematic lagrange multiplier internal data pointer
  //   int Kinematic_lagrange_index;

  // public:
  //   /// Constructor
  //   PointFluidInterfaceBoundingElement()
  //     : ContactLineElement(), Kinematic_lagrange_index(-1)
  //   {
  //     Kinematic_lagrange_index = add_internal_data(new Data(1));
  //     internal_data_pt(Kinematic_lagrange_index)->set_value(0, 1.0);
  //   }

  //   void fix_lagrange_multiplier(const double& value)
  //   {
  //     internal_data_pt(Kinematic_lagrange_index)->pin(0);
  //     internal_data_pt(Kinematic_lagrange_index)->set_value(0, value);
  //   }

  //   void free_lagrange_multiplier()
  //   {
  //     internal_data_pt(Kinematic_lagrange_index)->unpin(0);
  //   }

  //   void calculate_contact_angle(double& imposed_contact_angle,
  //                                double& computed_contact_angle)
  //   {
  //     // Let's get the info from the parent
  //     FiniteElement* parent_pt = bulk_element_pt();

  //     // Find the dimension of the problem
  //     unsigned spatial_dim = this->nodal_dimension();

  //     // Outer unit normal to the wall
  //     Vector<double> wall_normal(spatial_dim);

  //     // Outer unit normal to the free surface
  //     Vector<double> unit_normal(spatial_dim);

  //     // Storage for the coordinate
  //     Vector<double> x(spatial_dim);

  //     // Storage for the coordinate time derivative
  //     Vector<double> dx_dt(spatial_dim);

  //     // Get the unit normal to the wall
  //     wall_unit_normal(x, wall_normal);

  //     // Find the dimension of the parent
  //     unsigned n_dim = parent_pt->dim();

  //     // Dummy local coordinate, of size zero
  //     Vector<double> s_local(0);

  //     // Get the x coordinate
  //     this->interpolated_x(s_local, x);

  //     // Get the dx/dt of the coordinate
  //     const unsigned t_deriv = 1;
  //     this->interpolated_dxdt(s_local, t_deriv, dx_dt);

  //     // Find the local coordinates in the parent
  //     Vector<double> s_parent(n_dim);
  //     this->get_local_coordinate_in_bulk(s_local, s_parent);

  //     // Just get the outer unit normal
  //     dynamic_cast<FaceElement*>(parent_pt)->outer_unit_normal(s_parent,
  //                                                              unit_normal);


  //     // Get imposed contact angle
  //     if (Contact_angle_fct_flag)
  //     {
  //       contact_angle(dx_dt, imposed_contact_angle);
  //     }
  //     else
  //     {
  //       contact_angle(imposed_contact_angle);
  //     }

  //     // Find the dot product of the two vectors
  //     double dot = 0.0;
  //     for (unsigned i = 0; i < spatial_dim; i++)
  //     {
  //       dot += unit_normal[i] * wall_normal[i];
  //     }

  //     // Compute contact angle
  //     computed_contact_angle = acos(dot);
  //   }

  //   /// Overload the output function
  //   void output(std::ostream& outfile)
  //   {
  //     // Find the dimension of the problem
  //     unsigned spatial_dim = this->nodal_dimension();

  //     // Storage for the coordinate
  //     Vector<double> x(spatial_dim);

  //     // Dummy local coordinate, of size zero
  //     Vector<double> s_local(0);

  //     // Get the x coordinate
  //     this->interpolated_x(s_local, x);

  //     // Compute the contact angles
  //     double imposed_contact_angle = 0.0;
  //     double computed_contact_angle = 0.0;
  //     calculate_contact_angle(imposed_contact_angle, computed_contact_angle);


  //     // Output fields, x, y, alpha_input, alpha_output, lagrange_multiplier
  //     for (unsigned i = 0; i < spatial_dim; i++)
  //     {
  //       outfile << x[i] << ",";
  //     }
  //     std::streamsize ss = outfile.precision();
  //     outfile << std::fixed << std::setprecision(3);
  //     outfile << imposed_contact_angle * 180 / MathematicalConstants::Pi <<
  //     ","; outfile << computed_contact_angle * 180 /
  //     MathematicalConstants::Pi
  //             << ",";
  //     outfile << std::setprecision(ss);
  //     outfile << internal_data_pt(Kinematic_lagrange_index)->value(0);
  //     outfile << std::endl;
  //   }
  // };


  //==========================================================================
  /// Specialisation of the interface boundary constraint to a line
  //==========================================================================
  // class LineFluidInterfaceBoundingElement : public ContactLineElement
  // {
  // protected:
  //   /// Overload the helper function to calculate the residuals and
  //   /// (if flag==true) the Jacobian -- this function only deals with
  //   /// the part of the Jacobian that can be handled generically.
  //   /// Specific additional contributions may be provided in
  //   /// add_additional_residual_contributions_interface_boundary()
  //   void fill_in_generic_residual_contribution_interface_boundary(
  //     Vector<double>& residuals, DenseMatrix<double>& jacobian, unsigned
  //     flag);

  // public:
  //   /// Constructor
  //   LineFluidInterfaceBoundingElement() : ContactLineElement() {}
  // };

} // namespace oomph
#endif
