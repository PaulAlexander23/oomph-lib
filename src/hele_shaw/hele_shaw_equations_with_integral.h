#ifndef OOMPH_HELE_SHAW_EQUATIONS_WITH_INTEGRAL_HEADER
#define OOMPH_HELE_SHAW_EQUATIONS_WITH_INTEGRAL_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

#include "../generic/elements.h"
#include "../generic/oomph_utilities.h"

#include "hele_shaw_equations.h"

namespace oomph
{
  class HeleShawEquationsWithIntegral : public virtual HeleShawEquations
  {
  public:
    HeleShawEquationsWithIntegral()
      : HeleShawEquations(), Volume_external_data_index(0)
    {
    }

    //======================================================================
    /// Compute element residual Vector and/or element Jacobian matrix
    ///
    /// flag=1: compute both
    /// flag=0: compute only residual Vector
    ///
    /// Pure version without hanging nodes
    //======================================================================
    void fill_in_generic_residual_contribution_hele_shaw(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      const unsigned& flag);

  private:
    unsigned Volume_external_data_index;
  };

  //======================================================================
  /// Compute element residual Vector and/or element Jacobian matrix
  ///
  /// flag=1: compute both
  /// flag=0: compute only residual Vector
  ///
  /// Pure version without hanging nodes
  //======================================================================
  void HeleShawEquationsWithIntegral::
    fill_in_generic_residual_contribution_hele_shaw(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      const unsigned& flag)
  {
    // Find out how many nodes there are
    const unsigned n_node = nnode();

    // Set up memory for the shape and test functions
    Shape psi(n_node), test(n_node);
    DShape dpsidx(n_node, 2), dtestdx(n_node, 2);

    // Index at which the hele_shaw unknown is stored
    const unsigned p_nodal_index = p_index_hele_shaw();

    // Set the value of n_intpt
    const unsigned n_intpt = integral_pt()->nweight();

    // Integers to store the local equation and unknown numbers
    int local_eqn = 0, local_unknown = 0;

    // Loop over the integration points
    for (unsigned ipt = 0; ipt < n_intpt; ipt++)
    {
      // Get the integral weight
      double w = integral_pt()->weight(ipt);

      // Call the derivatives of the shape and test functions
      double J = dshape_and_dtest_eulerian_at_knot_hele_shaw(
        ipt, psi, dpsidx, test, dtestdx);

      // Premultiply the weights and the Jacobian
      double W = w * J;

      // Calculate local values of unknown
      // Allocate and initialise to zero
      double interpolated_p = 0.0;
      Vector<double> interpolated_x(2, 0.0);
      Vector<double> interpolated_dpdx(2, 0.0);

      // Calculate function value and derivatives:
      //-----------------------------------------
      // Loop over nodes
      for (unsigned l = 0; l < n_node; l++)
      {
        // Get the nodal value of the hele_shaw unknown
        double p_value = raw_nodal_value(l, p_nodal_index);
        interpolated_p += p_value * psi(l);
        // Loop over directions
        for (unsigned j = 0; j < 2; j++)
        {
          interpolated_x[j] += raw_nodal_position(l, j) * psi(l);
          interpolated_dpdx[j] += p_value * dpsidx(l, j);
        }
      }

      // Get gap width and wall velocity
      double h = 1.0;
      double dhdt = 0.0;
      get_upper_wall_data(ipt, interpolated_x, h, dhdt);

      // Assemble residuals and Jacobian
      //--------------------------------

      // Loop over the test functions
      for (unsigned l = 0; l < n_node; l++)
      {
        // Get the local equation
        local_eqn = nodal_local_eqn(l, p_nodal_index);
        /*IF it's not a boundary condition*/
        if (local_eqn >= 0)
        {
          // Wall velocity (RHS)
          residuals[local_eqn] += dhdt * test(l) * W;

          // The HeleShaw bit itself
          for (unsigned k = 0; k < 2; k++)
          {
            residuals[local_eqn] +=
              pow(h, 3) * interpolated_dpdx[k] * dtestdx(l, k) * W;
          }

          // Calculate the jacobian
          //-----------------------
          if (flag)
          {
            // Loop over the velocity shape functions again
            for (unsigned l2 = 0; l2 < n_node; l2++)
            {
              local_unknown = nodal_local_eqn(l2, p_nodal_index);
              // If at a non-zero degree of freedom add in the entry
              if (local_unknown >= 0)
              {
                // Add contribution to Elemental Matrix
                for (unsigned i = 0; i < 2; i++)
                {
                  jacobian(local_eqn, local_unknown) +=
                    pow(h, 3) * dpsidx(l2, i) * dtestdx(l, i) * W;
                }
              }
            }
          }
        }

        // Add the element's volume to external volume data
        unsigned i_value = 0;
        local_eqn = external_local_eqn(Volume_external_data_index, i_value);
        if (local_eqn >= 0)
        {
          // Calculate the fluid volume contained within the element
          residuals[local_eqn] += h * test(l) * W;
        }
      }

    } // End of loop over integration points
  }
}; // namespace oomph


#endif
