// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC//           Version 0.90. August 3, 2009.
// LIC//
// LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Header file for elements that are used to apply prescribed flux
// boundary conditions to the Poisson equations
#ifndef MY_HELE_SHAW_FLUX_ELEMENTS_HEADER
#define MY_HELE_SHAW_FLUX_ELEMENTS_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// oomph-lib includes
#include "generic.h"
#include "hele_shaw.h"

namespace oomph
{
  //======================================================================
  /// \short A class for elements that allow the imposition of an
  /// applied flux on the boundaries of Poisson elements.
  /// The element geometry is obtained from the  FaceGeometry<ELEMENT>
  /// policy class.
  //======================================================================
  template<class ELEMENT>
  class HeleShawFluxElementWithInflowIntegral
    : public virtual HeleShawFluxElement<ELEMENT>
  {
  public:
    /// \short Constructor, takes the pointer to the "bulk" element and the
    /// index of the face to which the element is attached.
    HeleShawFluxElementWithInflowIntegral(FiniteElement* const& bulk_el_pt,
                                          const int& face_index,
                                          Data* const& Inlet_integral_data_pt);

    /// Broken copy constructor
    HeleShawFluxElementWithInflowIntegral(
      const HeleShawFluxElementWithInflowIntegral& dummy)
    {
      BrokenCopy::broken_copy("HeleShawFluxElementWithInflowIntegral");
    }

    /// Broken assignment operator
    void operator=(const HeleShawFluxElementWithInflowIntegral&)
    {
      BrokenCopy::broken_assign("HeleShawFluxElementWithInflowIntegral");
    }

    /// Add the element's contribution to its residual vector
    inline void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      // Call the generic residuals function with flag set to 0
      // using a dummy matrix argument
      fill_in_generic_residual_contribution(
        residuals, GeneralisedElement::Dummy_matrix, 0);
    }

    /// \short Add the element's contribution to its residual vector and its
    /// Jacobian matrix
    inline void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                                 DenseMatrix<double>& jacobian)
    {
      // Call the generic routine with the flag set to 1
      fill_in_generic_residual_contribution(residuals, jacobian, 1);
      GeneralisedElement::fill_in_jacobian_from_external_by_fd(
        residuals, jacobian, false); /// Alice
    }

    void fill_in_contribution_to_jacobian_and_mass_matrix(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      DenseMatrix<double>& mass_matrix)
    {
      //            std::cout << "Calling jacobian and mass matrix in flux " <<
      //            std::endl;
      fill_in_contribution_to_jacobian(residuals, jacobian);
    }

  private:
    /// \short Add the element's contribution to its residual vector.
    /// flag=1(or 0): do (or don't) compute the contribution to the
    /// Jacobian as well.
    void fill_in_generic_residual_contribution(Vector<double>& residuals,
                                               DenseMatrix<double>& jacobian,
                                               const unsigned& flag);

    /// Integral data
    unsigned Integral_index;
  };

  //////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////
  //////////////////////////////////////////////////////////////////////


  //===========================================================================
  /// Constructor, takes the pointer to the "bulk" element, the
  /// index of the fixed local coordinate and its value represented
  /// by an integer (+/- 1), indicating that the face is located
  /// at the max. or min. value of the "fixed" local coordinate
  /// in the bulk element.
  //===========================================================================
  template<class ELEMENT>
  HeleShawFluxElementWithInflowIntegral<ELEMENT>::
    HeleShawFluxElementWithInflowIntegral(FiniteElement* const& bulk_el_pt,
                                          const int& face_index,
                                          Data* const& Inlet_integral_data_pt)
    : HeleShawFluxElement<ELEMENT>(bulk_el_pt, face_index)
  {
    /// We need to add the integral data as an external data to access the
    /// appropriate residual
    bool use_fd_for_jacobian = true;
    this->Integral_index =
      this->add_external_data(Inlet_integral_data_pt, use_fd_for_jacobian);
  }


  //===========================================================================
  /// Compute the element's residual vector and the (zero) Jacobian matrix.
  //===========================================================================
  template<class ELEMENT>
  void HeleShawFluxElementWithInflowIntegral<ELEMENT>::
    fill_in_generic_residual_contribution(Vector<double>& residuals,
                                          DenseMatrix<double>& jacobian,
                                          const unsigned& flag)
  {
    HeleShawFluxElement<
      ELEMENT>::fill_in_generic_residual_contribution_poisson_flux(residuals,
                                                                   jacobian,
                                                                   flag);

    // Find out how many nodes there are
    const unsigned n_node = FiniteElement::nnode();

    // Set up memory for the shape and test functions
    Shape psif(n_node), testf(n_node);

    // Set the value of Nintpt
    const unsigned n_intpt = this->integral_pt()->nweight();

    // Set the Vector to hold local coordinates
    Vector<double> s(this->Dim - 1);

    // Integers to hold the local equation and unknown numbers
    int local_eqn = 0;

    // Loop over the integration points
    //--------------------------------
    for (unsigned ipt = 0; ipt < n_intpt; ipt++)
    {
      // Assign values of s
      for (unsigned i = 0; i < (this->Dim - 1); i++)
      {
        s[i] = this->integral_pt()->knot(ipt, i);
      }

      // Get the integral weight
      double w = this->integral_pt()->weight(ipt);

      // Find the shape and test functions and return the Jacobian
      // of the mapping
      double J = this->shape_and_test(s, psif, testf);

      // Premultiply the weights and the Jacobian
      double W = w * J;

      // Need to find position to feed into flux function, initialise to zero
      Vector<double> interpolated_x(this->Dim, 0.0);

      // Calculate velocities and derivatives
      for (unsigned l = 0; l < n_node; l++)
      {
        // Loop over velocity components
        for (unsigned i = 0; i < this->Dim; i++)
        {
          interpolated_x[i] += this->nodal_position(l, i) * psif[l];
        }
      }

      // Get gap width and wall velocity
      double h = 1.0;
      double dhdt = 0.0;
      (**this->Upper_wall_fct_pt)(interpolated_x, h, dhdt);

      /// Add the contribution to the inlet integral
      unsigned value_index = 0;
      local_eqn = this->external_local_eqn(this->Integral_index, value_index);
      /// The integral doesn't depend on the shape functions
      residuals[local_eqn] += pow(h, 3.0) / 12 * W;
    }
  }


} // namespace oomph

#endif
