// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2022 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Header file for elements that are used to integrate fluid slips
// This includes the guts (i.e. equations) because we want to inline them
// for faster operation, although it slows down the compilation!
#ifndef OOMPH_AXISYM_FLUID_SLIP_ELEMENTS_HEADER
#define OOMPH_AXISYM_FLUID_SLIP_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif


// OOMPH-LIB headers
//#include "../generic/shape.h"
//#include "../generic/elements.h"
//#include "../generic/element_with_external_element.h"
#include "parameters.h"
#include "debug_jacobian_elements.h"

namespace oomph
{
  //======================================================================
  /// A class for elements that allow the imposition of an applied slip
  /// in the axisym Navier Stokes eqns.
  /// The geometrical information can be read from the FaceGeometry<ELEMENT>
  /// class and and thus, we can be generic enough without the need to have
  /// a separate equations class.
  //======================================================================
  template<class ELEMENT>
  class AxisymmetricNavierStokesSlipElement
    : public virtual FaceGeometry<ELEMENT>,
      public virtual AxisymmetricNavierStokesFaceElement,
      public virtual DebugJacobianSolidFiniteElement,
      public virtual SolidFaceElement
  {
  private:
    unsigned Contact_line_data_index;

  protected:
    /// Pointer to an imposed slip function. Arguments:
    /// Eulerian coordinate; outer unit normal;
    /// applied slip. (Not all of the input arguments will be
    /// required for all specific load functions but the list should
    /// cover all cases)
    void (*Slip_fct_pt)(const double& time,
                        const Vector<double>& x,
                        const Vector<double>& n,
                        Vector<double>& result);

    /// Pointer to an wall velocity function. Arguments:
    /// Eulerian coordinate; outer unit normal;
    /// applied velocity.
    void (*Wall_velocity_fct_pt)(const double& time,
                                 const Vector<double>& x,
                                 const Vector<double>& n,
                                 Vector<double>& result);

    /// Get the slip vector: Pass number of integration point
    /// (dummy), Eulerian coordinate and normal vector and return the load
    /// vector (not all of the input arguments will be required for all specific
    /// load functions but the list should cover all cases). This function is
    /// virtual so it can be overloaded for FSI.
    virtual void get_slip(const double& time,
                          const unsigned& intpt,
                          const Vector<double>& x,
                          const Vector<double>& n,
                          Vector<double>& slip) const
    {
      Slip_fct_pt(time, x, n, slip);
    }

    /// Get the wall velocity vector: Pass number of integration point
    /// (dummy), Eulerian coordinate and normal vector and return the load
    /// vector (not all of the input arguments will be required for all specific
    /// load functions but the list should cover all cases). This function is
    /// virtual so it can be overloaded for FSI.
    virtual void get_wall_velocity(const double& time,
                                   const unsigned& intpt,
                                   const Vector<double>& x,
                                   const Vector<double>& n,
                                   Vector<double>& wall_velocity) const
    {
      Wall_velocity_fct_pt(time, x, n, wall_velocity);
    }

    /// Helper function that actually calculates the residuals
    // This small level of indirection is required to avoid calling
    // fill_in_contribution_to_residuals in fill_in_contribution_to_jacobian
    // which causes all kinds of pain if overloading later on
    void fill_in_contribution_to_residuals_axisymmetric_nst_slip(
      Vector<double>& residuals, DenseMatrix<double>& jacobian, unsigned flag);

  public:
    /// Constructor, which takes a "bulk" element and the
    /// value of the index and its limit
    AxisymmetricNavierStokesSlipElement(FiniteElement* const& element_pt,
                                        const int& face_index)
      : FaceGeometry<ELEMENT>(),
        AxisymmetricNavierStokesFaceElement(),
        SolidFaceElement()
    {
      // Attach the geometrical information to the element. N.B. This function
      // also assigns nbulk_value from the required_nvalue of the bulk element
      element_pt->build_face_element(face_index, this);

      this->add_other_bulk_node_positions_as_external_data();
    }

    /// Constructor, which takes a "bulk" element and the
    /// value of the index and its limit
    AxisymmetricNavierStokesSlipElement(FiniteElement* const& element_pt,
                                        const int& face_index,
                                        SolidNode* const& contact_line_node_pt)
      : FaceGeometry<ELEMENT>(), FaceElement()
    {
      // Attach the geometrical information to the element. N.B. This function
      // also assigns nbulk_value from the required_nvalue of the bulk element
      element_pt->build_face_element(face_index, this);

      // Contact_line_data_index =
      add_external_data(contact_line_node_pt->variable_position_pt());
    }


    /// Reference to the slip function pointer
    void (*&slip_fct_pt())(const double& time,
                           const Vector<double>& x,
                           const Vector<double>& n,
                           Vector<double>& slip)
    {
      return Slip_fct_pt;
    }

    /// Reference to the wall velocity function pointer
    void (*&wall_velocity_fct_pt())(const double& time,
                                    const Vector<double>& x,
                                    const Vector<double>& n,
                                    Vector<double>& slip)
    {
      return Wall_velocity_fct_pt;
    }


    //================================================================
    /// Calculate the i-th velocity component at local coordinate s
    //================================================================
    Vector<double> interpolated_u(const Vector<double>& s)
    {
      // Find number of nodes
      unsigned n_node = this->nnode();

      // Storage for the local shape function
      Shape psi(n_node);

      // Get values of shape function at local coordinate s
      this->shape(s, psi);

      // Initialise value of u
      unsigned n_dim = this->nodal_dimension();
      Vector<double> interpolated_u(n_dim + 1, 0.0);

      // Loop over the local nodes and sum
      for (unsigned l = 0; l < n_node; l++)
      {
        for (unsigned i = 0; i < n_dim + 1; i++)
        {
          interpolated_u[i] += u(l, i) * psi(l);
        }
      }

      return (interpolated_u);
    }

    //================================================================
    /// Calculate the i-th velocity component at local coordinate s
    //================================================================
    Vector<double> interpolated_wall_velocity(const Vector<double>& s)
    {
      // Find number of nodes
      unsigned n_node = FiniteElement::nnode();

      // Storage for the local shape function
      Shape psi(n_node);

      // Get values of shape function at local coordinate s
      this->shape(s, psi);

      // Initialise value of u
      unsigned n_dim = this->nodal_dimension();
      Vector<double> interpolated_x(n_dim, 0.0);

      // Loop over the local nodes and sum
      for (unsigned l = 0; l < n_node; l++)
      {
        for (unsigned i = 0; i < n_dim; i++)
        {
          interpolated_x[i] += nodal_position(l, i) * psi(l);
        }
      }
      Vector<double> unit_normal(n_dim);
      outer_unit_normal(s, unit_normal);
      Vector<double> wall_velocity(n_dim + 1);
      get_wall_velocity(0.0, 0, interpolated_x, unit_normal, wall_velocity);

      return (wall_velocity);
    }


    void fill_in_contribution_to_dresiduals_dparameter(
      double* const& parameter_pt, Vector<double>& dres_dparam)
    {
      if (parameter_pt == &Slip_Parameters::wall_velocity)
      {
        // Find out how many nodes there are
        unsigned n_node = nnode();

        // Get continuous time from timestepper of first node
        double time = node_pt(0)->time_stepper_pt()->time_pt()->time();

#ifdef PARANOID
        // Find out how many positional dofs there are
        unsigned n_position_type = this->nnodal_position_type();
        if (n_position_type != 1)
        {
          throw OomphLibError(
            "AxisymmetricNavierStokes is not yet implemented for "
            "more than one position type",
            OOMPH_CURRENT_FUNCTION,
            OOMPH_EXCEPTION_LOCATION);
        }
#endif

        // Find out the dimension of the node
        unsigned n_dim = this->nodal_dimension();

        // Integer to hold the local equation number
        int local_eqn = 0;

        // Set up memory for the shape functions
        // Note that in this case, the number of lagrangian coordinates is
        // always equal to the dimension of the nodes
        Shape psi(n_node);
        DShape dpsids(n_node, n_dim - 1);

        // Set the value of n_intpt
        unsigned n_intpt = integral_pt()->nweight();

        // Loop over the integration points
        for (unsigned ipt = 0; ipt < n_intpt; ipt++)
        {
          // Get the integral weight
          double w = integral_pt()->weight(ipt);

          // Only need to call the local derivatives
          dshape_local_at_knot(ipt, psi, dpsids);

          // Calculate the Eulerian and Lagrangian coordinates
          Vector<double> interpolated_x(n_dim, 0.0);
          Vector<double> interpolated_t(n_dim, 0.0);
          Vector<double> interpolated_u(n_dim + 1, 0.0);

          // Calculate positions and derivatives
          for (unsigned l = 0; l < n_node; l++)
          {
            // Loop over directions
            for (unsigned i = 0; i < n_dim; i++)
            {
              // Calculate the Eulerian coords
              const double x_local = nodal_position(l, i);
              interpolated_x[i] += x_local * psi(l);
              interpolated_t[i] += x_local * dpsids(l, 0);
            }

            // Loop over directions
            for (unsigned i = 0; i < n_dim + 1; i++)
            {
              interpolated_u[i] += u(l, i) * psi(l);
            }
          }

          // Get the outer unit normal
          Vector<double> interpolated_normal(n_dim);
          outer_unit_normal(ipt, interpolated_normal);

          // Add the azimuthal direction manually
          interpolated_normal.push_back(0.0);

          // Calculate the length of the tangent Vector
          double tlength = interpolated_t[0] * interpolated_t[0] +
                           interpolated_t[1] * interpolated_t[1];

          // Set the Jacobian of the line element
          // multiplied by r (x[0])
          double J = sqrt(tlength) * interpolated_x[0];

          // Premultiply the weights and the square-root of the determinant of
          // the metric tensor
          double W = w * J;

          // Now calculate the load
          Vector<double> slip(n_dim + 1);
          get_slip(time, ipt, interpolated_x, interpolated_normal, slip);

          Vector<double> wall_velocity(n_dim + 1);
          get_wall_velocity(
            time, ipt, interpolated_x, interpolated_normal, wall_velocity);

          // Subtract off the wall velocity
          for (unsigned i = 0; i < n_dim; i++)
          {
            interpolated_u[i] = interpolated_u[i] - wall_velocity[i];
          }

          // Project velocity onto tangent plane
          Vector<double> interpolated_u_tangent(n_dim + 1, 0.0);
          double dot = 0.0;
          for (unsigned i = 0; i < n_dim + 1; i++)
          {
            dot += interpolated_u[i] * interpolated_normal[i];
          }
          for (unsigned i = 0; i < n_dim + 1; i++)
          {
            interpolated_u_tangent[i] =
              interpolated_u[i] - dot * interpolated_normal[i];
          }

          // Loop over the test functions, nodes of the element
          for (unsigned l = 0; l < n_node; l++)
          {
            // Loop over the velocity components
            for (unsigned i = 0; i < n_dim + 1; i++)
            {
              // Equation number
              local_eqn =
                this->nodal_local_eqn(l, this->axi_momentum_index_nst(l, i));
              /*IF it's not a boundary condition*/
              if (local_eqn >= 0)
              {
                // Add the slip terms to the residuals
                if (slip[i] > 0)
                {
                  dres_dparam[local_eqn] -= 1.0 / slip[i] * psi(l) * W;
                }
              }
            }
          } // End of loop over shape functions
        } // End of loop over integration points
      }
    }

    /// Compute the element's residual Vector and the jacobian matrix
    /// Virtual function can be overloaded by hanging-node version
    void fill_in_contribution_to_djacobian_dparameter(
      double* const& parameter_pt,
      Vector<double>& dres_dparam,
      DenseMatrix<double>& djac_dparam)
    {
    }


    /// Return the residuals
    void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      fill_in_contribution_to_residuals_axisymmetric_nst_slip(
        residuals, GeneralisedElement::Dummy_matrix, 0);
    }


    /// Fill in contribution from Jacobian
    void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                          DenseMatrix<double>& jacobian)
    {
      // Fill in analytic contribution of internal equations
      fill_in_contribution_to_residuals_axisymmetric_nst_slip(
        residuals, jacobian, 1);

      // Fill in the solid position contribution by finite differences
      fill_in_jacobian_from_solid_position_by_fd(jacobian);

      // Fill in the contribution from external data by finite differences
      fill_in_jacobian_from_external_by_fd(residuals, jacobian, false);
    }

    void fill_in_contribution_to_jacobian_and_mass_matrix(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      DenseMatrix<double>& mass_matrix)
    {
      //  Fill in analytic contribution of internal equations
      fill_in_contribution_to_residuals_axisymmetric_nst_slip(
        residuals, jacobian, 1);

      // Fill in the solid position contribution by finite differences
      fill_in_jacobian_from_solid_position_by_fd(jacobian);

      // Fill in the contribution from external data by finite differences
      fill_in_jacobian_from_external_by_fd(residuals, jacobian, false);
    }

    /// Specify the value of nodal zeta from the face geometry
    /// The "global" intrinsic coordinate of the element when
    /// viewed as part of a geometric object should be given by
    /// the FaceElement representation, by default (needed to break
    /// indeterminacy if bulk element is SolidElement)
    double zeta_nodal(const unsigned& n,
                      const unsigned& k,
                      const unsigned& i) const
    {
      return FaceElement::zeta_nodal(n, k, i);
    }

    /// Output function
    void output(std::ostream& outfile)
    {
      unsigned nplot = 3;
      output(outfile, nplot);
    }

    /// Number of scalars/fields output by this element. Reimplements
    /// broken virtual function in base class.
    unsigned nscalar_paraview() const
    {
      // Number of dimensions
      unsigned n_dim = this->nodal_dimension();

      return 2 * (n_dim + 1);
    }

    /// Write values of the k-th scalar field at the plot points. Needs
    /// to be implemented for each new specific element type.
    void scalar_value_paraview(std::ofstream& file_out,
                               const unsigned& k,
                               const unsigned& nplot) const
    {
      // Number of dimensions
      unsigned n_dim = this->nodal_dimension();

      // Find out how many nodes there are
      const unsigned n_node = nnode();

      // Get continuous time from timestepper of first node
      double time = node_pt(0)->time_stepper_pt()->time_pt()->time();

      // Set up memory for the shape functions
      Shape psi(n_node);

      // Local and global coordinates
      Vector<double> s(n_dim - 1);
      Vector<double> interpolated_x(n_dim);

      // Loop over plot points
      unsigned num_plot_points = this->nplot_points_paraview(nplot);
      for (unsigned iplot = 0; iplot < num_plot_points; iplot++)
      {
        // Get local coordinates of plot point
        this->get_s_plot(iplot, nplot, s);

        // Outer unit normal
        Vector<double> unit_normal(n_dim);
        outer_unit_normal(s, unit_normal);

        // Find the shape functions
        shape(s, psi);

        // Initialise to zero
        for (unsigned i = 0; i < n_dim; i++)
        {
          interpolated_x[i] = 0.0;
        }

        // Calculate stuff
        for (unsigned l = 0; l < n_node; l++)
        {
          // Loop over directions
          for (unsigned i = 0; i < n_dim; i++)
          {
            interpolated_x[i] += this->nodal_position(l, i) * psi[l];
          }
        }

        // Get the imposed slip
        Vector<double> slip(3);

        // Dummy integration point
        unsigned ipt = 0;
        get_slip(time, ipt, interpolated_x, unit_normal, slip);

        // Slip components
        if (k < n_dim + 1)
        {
          file_out << slip[k] << std::endl;
        }
        // Advection Diffusion
        else if (k < 2 * n_dim + 1 && k >= n_dim + 1)
        {
          file_out << unit_normal[k] << std::endl;
        }
        // Never get here
        else
        {
          std::stringstream error_stream;
          error_stream
            << "Axisymmetric Fluid Slip Navier-Stokes Elements only store "
            << 2 * (n_dim + 1) << " fields " << std::endl;
          throw OomphLibError(error_stream.str(),
                              OOMPH_CURRENT_FUNCTION,
                              OOMPH_EXCEPTION_LOCATION);
        }
      }
    }

    /// Name of the i-th scalar field. Default implementation
    /// returns V1 for the first one, V2 for the second etc. Can (should!) be
    /// overloaded with more meaningful names in specific elements.
    std::string scalar_name_paraview(const unsigned& i) const
    {
      // Number of dimensions
      unsigned n_dim = this->nodal_dimension();

      // Slip components
      if (i < n_dim + 1)
      {
        return "Slip component " + StringConversion::to_string(i);
      }
      // Normals
      else if (i < 2 * n_dim + 1 && i >= n_dim + 1)
      {
        return "Normal " + StringConversion::to_string(i % (n_dim + 1));
      }
      // Never get here
      else
      {
        std::stringstream error_stream;
        error_stream
          << "Axisymmetric Fluid Slip Navier-Stokes Elements only store "
          << 2 * (n_dim + 1) << " fields " << std::endl;
        throw OomphLibError(
          error_stream.str(), OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
      }
    }

    /// Return the i-th velocity component at local node n
    /// The default is to asssume that n is the local node number
    /// and the i-th velocity component is the i-th unknown stored at the
    /// node.
    virtual inline double u(const unsigned& n, const unsigned& i)
    {
      return node_pt(n)->value(this->u_index_axi_nst(n, i));
    }

    //================================================================
    /// Calculate the pressure component at local coordinate s
    //================================================================
    double interpolated_p(const Vector<double>& s)
    {
      // Find corresponding coordinate in the the bulk element
      Vector<double> s_bulk(this->dim() + 1);
      s_bulk = this->local_coordinate_in_bulk(s);

      // Get cast bulk element
      ELEMENT* bulk_el_pt = dynamic_cast<ELEMENT*>(this->bulk_element_pt());

      // Get the pressure from the bulk element
      double interpolated_p = bulk_el_pt->interpolated_p_nst(s_bulk);

      /// Return the interpolated pressure
      return (interpolated_p);
    }


    /// Output function
    void output(std::ostream& outfile, const unsigned& n_plot)
    {
      // Number of dimensions
      unsigned n_dim = this->nodal_dimension();

      // Find out how many nodes there are
      const unsigned n_node = nnode();

      // Get continuous time from timestepper of first node
      double time = node_pt(0)->time_stepper_pt()->time_pt()->time();

      // Set up memory for the shape functions
      Shape psi(n_node);

      // Local and global coordinates
      Vector<double> s(n_dim - 1);

      // Loop over plot points
      unsigned num_plot_points = this->nplot_points(n_plot);
      for (unsigned iplot = 0; iplot < num_plot_points; iplot++)
      {
        // Get local coordinates of plot point
        this->get_s_plot(iplot, n_plot, s);

        // Outer unit normal
        Vector<double> unit_normal(n_dim);
        outer_unit_normal(s, unit_normal);

        // Find the shape functions
        shape(s, psi);

        // Initialise to zero
        Vector<double> interpolated_x(n_dim);
        Vector<double> interpolated_u(n_dim + 1);

        // Calculate stuff
        for (unsigned l = 0; l < n_node; l++)
        {
          // Loop over directions
          for (unsigned i = 0; i < n_dim; i++)
          {
            interpolated_x[i] += this->nodal_position(l, i) * psi[l];
          }

          for (unsigned i = 0; i < n_dim + 1; i++)
          {
            interpolated_u[i] += this->u(l, i) * psi[l];
          }
        }

        // Get the imposed slip
        Vector<double> slip(3);

        // Dummy integration point
        unsigned ipt = 0;
        get_slip(time, ipt, interpolated_x, unit_normal, slip);

        Vector<double> wall_velocity(n_dim + 1);
        get_wall_velocity(
          time, ipt, interpolated_x, unit_normal, wall_velocity);

        // Output the x,y,..
        for (unsigned i = 0; i < n_dim; i++)
        {
          outfile << interpolated_x[i] << " ";
        }

        // Output the slip components
        for (unsigned i = 0; i < n_dim + 1; i++)
        {
          outfile << slip[i] << " ";
        }

        // Output normal
        for (unsigned i = 0; i < n_dim; i++)
        {
          outfile << unit_normal[i] << " ";
        }

        // Output the u,v,w
        for (unsigned i = 0; i < n_dim + 1; i++)
        {
          outfile << wall_velocity[i] << " ";
        }

        // Output the u,v,w
        for (unsigned i = 0; i < n_dim + 1; i++)
        {
          outfile << interpolated_u[i] << " ";
        }
        outfile << interpolated_p(s) << std::endl;
      }
    }

    /// C_style output function
    void output(FILE* file_pt)
    {
      FiniteElement::output(file_pt);
    }

    /// C-style output function
    void output(FILE* file_pt, const unsigned& n_plot)
    {
      FiniteElement::output(file_pt, n_plot);
    }


    /// Compute slip vector at specified local coordinate
    /// Should only be used for post-processing; ignores dependence
    /// on integration point!
    void slip(const double& time,
              const Vector<double>& s,
              Vector<double>& slip);
  };

  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////

  //=====================================================================
  /// Compute slip vector at specified local coordinate
  /// Should only be used for post-processing; ignores dependence
  /// on integration point!
  //=====================================================================
  template<class ELEMENT>
  void AxisymmetricNavierStokesSlipElement<ELEMENT>::slip(
    const double& time, const Vector<double>& s, Vector<double>& slip)
  {
    unsigned n_dim = this->nodal_dimension();

    // Position vector
    Vector<double> x(n_dim);
    interpolated_x(s, x);

    // Outer unit normal (only in r and z direction!)
    Vector<double> unit_normal(n_dim);
    outer_unit_normal(s, unit_normal);

    // Dummy
    unsigned ipt = 0;

    // Slip vector
    get_slip(time, ipt, x, unit_normal, slip);
  }


  //=====================================================================
  /// Return the residuals for the
  /// AxisymmetricNavierStokesSlipElement equations
  //=====================================================================
  template<class ELEMENT>
  void AxisymmetricNavierStokesSlipElement<ELEMENT>::
    fill_in_contribution_to_residuals_axisymmetric_nst_slip(
      Vector<double>& residuals, DenseMatrix<double>& jacobian, unsigned flag)
  {
    // Find out how many nodes there are
    unsigned n_node = nnode();

    // Get continuous time from timestepper of first node
    double time = node_pt(0)->time_stepper_pt()->time_pt()->time();

#ifdef PARANOID
    // Find out how many positional dofs there are
    unsigned n_position_type = this->nnodal_position_type();
    if (n_position_type != 1)
    {
      throw OomphLibError("AxisymmetricNavierStokes is not yet implemented for "
                          "more than one position type",
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
    }
#endif

    // Find out the dimension of the node
    unsigned n_dim = this->nodal_dimension();

    // Integer to hold the local equation number
    int local_eqn = 0;
    int local_unknown = 0;

    // Set up memory for the shape functions
    // Note that in this case, the number of lagrangian coordinates is always
    // equal to the dimension of the nodes
    Shape psi(n_node);
    DShape dpsids(n_node, n_dim - 1);

    // Set the value of n_intpt
    unsigned n_intpt = integral_pt()->nweight();

    // Loop over the integration points
    for (unsigned ipt = 0; ipt < n_intpt; ipt++)
    {
      // Get the integral weight
      double w = integral_pt()->weight(ipt);

      // Only need to call the local derivatives
      dshape_local_at_knot(ipt, psi, dpsids);

      // Calculate the Eulerian and Lagrangian coordinates
      Vector<double> interpolated_x(n_dim, 0.0);
      Vector<double> interpolated_t(n_dim, 0.0);
      Vector<double> interpolated_u(n_dim + 1, 0.0);

      // Calculate positions and derivatives
      for (unsigned l = 0; l < n_node; l++)
      {
        // Loop over directions
        for (unsigned i = 0; i < n_dim; i++)
        {
          // Calculate the Eulerian coords
          const double x_local = nodal_position(l, i);
          interpolated_x[i] += x_local * psi(l);
          interpolated_t[i] += x_local * dpsids(l, 0);
        }

        // Loop over directions
        for (unsigned i = 0; i < n_dim + 1; i++)
        {
          interpolated_u[i] += u(l, i) * psi(l);
        }
      }

      // Get the outer unit normal
      Vector<double> interpolated_normal(n_dim);
      outer_unit_normal(ipt, interpolated_normal);

      // Add the azimuthal direction manually
      interpolated_normal.push_back(0.0);

      // Calculate the length of the tangent Vector
      double tlength = interpolated_t[0] * interpolated_t[0] +
                       interpolated_t[1] * interpolated_t[1];

      // Set the Jacobian of the line element
      // multiplied by r (x[0])
      double J = sqrt(tlength) * interpolated_x[0];

      // Premultiply the weights and the square-root of the determinant of
      // the metric tensor
      double W = w * J;

      // Now calculate the load
      Vector<double> slip(n_dim + 1);
      get_slip(time, ipt, interpolated_x, interpolated_normal, slip);

      Vector<double> wall_velocity(n_dim + 1);
      get_wall_velocity(
        time, ipt, interpolated_x, interpolated_normal, wall_velocity);

      // Subtract off the wall velocity
      for (unsigned i = 0; i < n_dim; i++)
      {
        interpolated_u[i] = interpolated_u[i] - wall_velocity[i];
      }

      // Project velocity onto tangent plane
      Vector<double> interpolated_u_tangent(n_dim + 1, 0.0);
      double dot = 0.0;
      for (unsigned i = 0; i < n_dim + 1; i++)
      {
        dot += interpolated_u[i] * interpolated_normal[i];
      }
      for (unsigned i = 0; i < n_dim + 1; i++)
      {
        interpolated_u_tangent[i] =
          interpolated_u[i] - dot * interpolated_normal[i];
      }

      const bool is_pseudo_solid = false;

      // Loop over the test functions, nodes of the element
      for (unsigned l = 0; l < n_node; l++)
      {
        // Loop over the velocity components
        for (unsigned i = 0; i < n_dim + 1; i++)
        {
          // Equation number
          local_eqn =
            this->nodal_local_eqn(l, this->axi_momentum_index_nst(l, i));
          /*IF it's not a boundary condition*/
          if (local_eqn >= 0)
          {
            // Add the slip terms to the residuals
            if (slip[i] > 0)
            {
              // residuals[local_eqn] -=
              //   1.0 / slip[i] * psi(l) * interpolated_u_tangent[i] * W;
              residuals[local_eqn] -=
                1.0 / slip[i] * psi(l) * interpolated_u[i] * W;

              // Add in the Jacobian term
              if (flag)
              {
                // Loop over the test functions, nodes of the element
                for (unsigned l2 = 0; l2 < n_node; l2++)
                {
                  local_unknown =
                    this->nodal_local_eqn(l2, this->u_index_axi_nst(l2, i));
                  // If it's a non-zero dof add
                  if (local_unknown >= 0)
                  {
                    jacobian(local_eqn, local_unknown) -=
                      1.0 / slip[i] * psi(l) *
                      (1 - interpolated_normal[l2] * interpolated_normal[i]) *
                      psi(l2) * W;
                  }

                  // Include the solid position contributions
                  if (is_pseudo_solid)
                  {
                    // Loop over the dimensions
                    for (unsigned j = 0; j < n_dim; j++)
                    {
                      local_unknown = this->position_local_eqn(l2, 1, j);
                      if (local_unknown >= 0)
                      {
                        // First of all for the tangential contribution. Note
                        // that actually there is no explicit J dependence
                        // (hence we use little w) so all we have is the
                        // contribution to the interpolated_t s -> this is
                        // always dpsifds(l2,0)
                        jacobian(local_eqn, local_unknown) +=
                          1.0 / slip[i] * psi(l) * u(i, l2) * dpsids(l2, 0) * w;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } // End of loop over shape functions
    } // End of loop over integration points
  }

} // namespace oomph


#endif
