// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2023 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Header file for general linear elasticity elements

// Include guards to prevent multiple inclusion of the header
#ifndef OOMPH_DECOMPOSED_PVD_ELEMENTS_HEADER
#define OOMPH_DECOMPOSED_PVD_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// OOMPH-LIB headers
#include "generic.h"
#include "solid.h"

namespace oomph
{
  //=======================================================================
  /// A base class for elements that solve the equations of linear
  /// elasticity in Cartesian coordinates.
  /// Combines a few generic functions that are shared by
  /// DecomposedPVDEquations
  /// and DecomposedPVDEquationsWithPressure (hierher: The latter
  /// don't exist yet but will be written as soon as somebody needs them...)
  //=======================================================================
  template<unsigned DIM>
  class DecomposedPVDEquationsBase : public virtual FiniteElement
  {
  public:
    /// Return the index at which the i-th unknown displacement
    /// component is stored. The default value, i, is appropriate for
    /// single-physics problems.
    virtual inline unsigned u_index_pvd(const unsigned& n,
                                        const unsigned& i,
                                        const unsigned& j) const
    {
      return i + DIM * j;
    }

    void pin_Xhat(const unsigned& n, const unsigned& i, const unsigned& j)
    {
      this->node_pt(n)->pin(u_index_pvd(n, i, j));
    }

    void set_value_Xhat(const unsigned& n,
                        const unsigned& i,
                        const unsigned& j,
                        const double& value)
    {
      this->node_pt(n)->set_value(u_index_pvd(n, i, j), value);
    }

    /// d^2u/dt^2 at local node n
    double d2u_dt2_pvd(const unsigned& n,
                       const unsigned& i,
                       const unsigned& j) const
    {
      // Get the timestepper
      TimeStepper* time_stepper_pt = node_pt(n)->time_stepper_pt();

      // Storage for the derivative - initialise to 0
      double d2u_dt2 = 0.0;

      // If we are doing an unsteady solve then calculate the derivative
      if (!time_stepper_pt->is_steady())
      {
        // Get the nodal index
        const unsigned u_nodal_index = u_index_pvd(n, i, j);

        // Get the number of values required to represent history
        const unsigned n_time = time_stepper_pt->ntstorage();

        // Loop over history values
        for (unsigned t = 0; t < n_time; t++)
        {
          // Add the contribution to the derivative
          d2u_dt2 +=
            time_stepper_pt->weight(2, t) * nodal_value(t, n, u_nodal_index);
        }
      }

      return d2u_dt2;
    }

    /// Compute vector of FE interpolated displacement u at local coordinate s
    void interpolated_u_pvd(const Vector<double>& s,
                            const unsigned& j,
                            Vector<double>& disp) const
    {
      // Find number of nodes
      unsigned n_node = nnode();

      // Local shape function
      Shape psi(n_node);

      // Find values of shape function
      shape(s, psi);

      for (unsigned i = 0; i < DIM; i++)
      {
        // Initialise value of u
        disp[i] = 0.0;

        // Loop over the local nodes and sum
        for (unsigned l = 0; l < n_node; l++)
        {
          disp[i] += u_pvd(l, i, j) * psi[l];
        }
      }
    }

    /// Return displacement u[i] at node l
    double u_pvd(const unsigned& l, const unsigned& i, const unsigned& j) const
    {
      unsigned u_nodal_index = u_index_pvd(l, i, j);

      // Displacements
      return nodal_value(l, u_nodal_index);
    }

    /// Return displacement u[i] at node l
    double du_pvd_dt(const unsigned& derivative,
                     const unsigned& l,
                     const unsigned& i,
                     const unsigned& j) const
    {
      // Get the timestepper
      TimeStepper* time_stepper_pt = node_pt(l)->time_stepper_pt();

      // Storage for the derivative - initialise to 0
      double value = 0.0;

      // If we are doing an unsteady solve then calculate the derivative
      if (!time_stepper_pt->is_steady())
      {
        // Add the contribution to the derivative
        unsigned u_nodal_index = u_index_pvd(l, i, j);

        // Get the number of values required to represent history
        const unsigned n_time = time_stepper_pt->ntstorage();

        // Loop over history values
        for (unsigned t = 0; t < n_time; t++)
        {
          value += time_stepper_pt->weight(derivative, t) *
                   nodal_value(t, l, u_nodal_index);
        }
      }
      return value;
    }

    /// Return FE interpolated displacement u[i] at local coordinate s
    double interpolated_u_pvd(const Vector<double>& s,
                              const unsigned& i,
                              const unsigned& j) const
    {
      // Find number of nodes
      unsigned n_node = nnode();

      // Local shape function
      Shape psi(n_node);

      // Find values of shape function
      shape(s, psi);


      // Initialise value of u
      double interpolated_u = 0.0;

      // Loop over the local nodes and sum
      for (unsigned l = 0; l < n_node; l++)
      {
        // Get nodal index at which i-th velocity is stored
        unsigned u_nodal_index = u_index_pvd(l, i, j);
        interpolated_u += nodal_value(l, u_nodal_index) * psi[l];
      }

      return (interpolated_u);
    }

  private:
    /// Static "magic" number that indicates that the solid pressure
    /// is not stored at a node
    static int Solid_pressure_not_stored_at_node;

  public:
    /// Function pointer to function that specifies the isotropic
    /// growth as a function of the Lagrangian coordinates FCT(xi,gamma(xi))
    /// -- xi is a Vector!
    typedef void (*IsotropicGrowthFctPt)(const Vector<double>& xi,
                                         double& gamma);

    /// Function pointer to function that specifies the pre-stress
    /// sigma_0(i,j) as a function of the Lagrangian coordinates
    /// FCT(i,j,xi) --  xi is a Vector!
    typedef double (*PrestressFctPt)(const unsigned& i,
                                     const unsigned& j,
                                     const Vector<double>& xi);

    /// Function pointer to function that specifies the body force
    /// as a function of the Cartesian coordinates and time FCT(t,x,b) --
    /// x and b are  Vectors!
    typedef void (*BodyForceFctPt)(const double& t,
                                   const Vector<double>& x,
                                   Vector<double>& b);

    /// Constructor: Set null pointers for constitutive law and for
    /// isotropic growth function. Set physical parameter values to
    /// default values, enable inertia and set body force to zero.
    /// Default evaluation of Jacobian: analytically rather than by FD.
    DecomposedPVDEquationsBase()
      : Isotropic_growth_fct_pt(0),
        Prestress_fct_pt(0),
        Constitutive_law_pt(0),
        Lambda_sq_pt(&Default_lambda_sq_value),
        Unsteady(true),
        Body_force_fct_pt(0),
        Evaluate_jacobian_by_fd(false)
    {
    }

    /// Return the constitutive law pointer
    ConstitutiveLaw*& constitutive_law_pt()
    {
      return Constitutive_law_pt;
    }


    /// Access function for timescale ratio (nondim density)
    const double& lambda_sq() const
    {
      return *Lambda_sq_pt;
    }


    /// Access function for pointer to timescale ratio (nondim density)
    double*& lambda_sq_pt()
    {
      return Lambda_sq_pt;
    }


    /// Access function: Pointer to isotropic growth function
    IsotropicGrowthFctPt& isotropic_growth_fct_pt()
    {
      return Isotropic_growth_fct_pt;
    }

    /// Access function: Pointer to pre-stress function
    PrestressFctPt& prestress_fct_pt()
    {
      return Prestress_fct_pt;
    }

    /// Access function: Pointer to isotropic growth function (const
    /// version)
    IsotropicGrowthFctPt isotropic_growth_fct_pt() const
    {
      return Isotropic_growth_fct_pt;
    }

    /// Access function: Pointer to body force function
    BodyForceFctPt& body_force_fct_pt()
    {
      return Body_force_fct_pt;
    }

    /// Access function: Pointer to body force function (const version)
    BodyForceFctPt body_force_fct_pt() const
    {
      return Body_force_fct_pt;
    }

    /// Switch on solid inertia
    void enable_inertia()
    {
      Unsteady = true;
    }

    /// Switch off solid inertia
    void disable_inertia()
    {
      Unsteady = false;
    }

    /// Access function to flag that switches inertia on/off (const version)
    bool is_inertia_enabled() const
    {
      return Unsteady;
    }

    /// Return the number of solid pressure degrees of freedom
    /// Default is that there are no solid pressures
    virtual unsigned npres_solid() const
    {
      return 0;
    }

    /// Return the local degree of freedom associated with the
    /// i-th solid pressure. Default is that there are none.
    virtual int solid_p_local_eqn(const unsigned& i) const
    {
      return -1;
    }

    /// Return the index at which the solid pressure is stored if it
    /// is stored at the nodes. If not stored at the nodes this will return
    /// a negative number.
    virtual int solid_p_nodal_index() const
    {
      return Solid_pressure_not_stored_at_node;
    }


    /// Unpin all solid pressure dofs in the element
    virtual void unpin_elemental_solid_pressure_dofs() = 0;

    /// Pin the element's redundant solid pressures (needed for refinement)
    virtual void pin_elemental_redundant_nodal_solid_pressures() {}

    ///  Loop over all elements in Vector (which typically contains
    /// all the elements in a refineable solid mesh) and pin the nodal solid
    /// pressure  degrees of freedom that are not being used. Function uses
    /// the member function
    /// - \c PVDEquationsBase<DIM>::
    ///      pin_elemental_redundant_nodal_pressure_dofs()
    /// .
    /// which is empty by default and should be implemented for
    /// elements with nodal solid pressure degrees of freedom
    /// (e.g. solid elements with continuous pressure interpolation.)
    static void pin_redundant_nodal_solid_pressures(
      const Vector<GeneralisedElement*>& element_pt)
    {
      // Loop over all elements
      unsigned n_element = element_pt.size();
      for (unsigned e = 0; e < n_element; e++)
      {
        dynamic_cast<PVDEquationsBase<DIM>*>(element_pt[e])
          ->pin_elemental_redundant_nodal_solid_pressures();
      }
    }

    /// Unpin all pressure dofs in elements listed in vector.
    static void unpin_all_solid_pressure_dofs(
      const Vector<GeneralisedElement*>& element_pt)
    {
      // Loop over all elements
      unsigned n_element = element_pt.size();
      for (unsigned e = 0; e < n_element; e++)
      {
        dynamic_cast<PVDEquationsBase<DIM>*>(element_pt[e])
          ->unpin_elemental_solid_pressure_dofs();
      }
    }

    /// Evaluate isotropic growth function at Lagrangian coordinate xi
    /// and/or local coordinate s.
    /// (returns 1, i.e. no growth, if no function pointer has been set)
    /// This function is virtual to allow overloading in multi-physics
    /// problems where the growth function might be determined by
    /// another system of equations
    virtual inline void get_isotropic_growth(const unsigned& ipt,
                                             const Vector<double>& s,
                                             const Vector<double>& xi,
                                             double& gamma) const
    {
      // If no function has been set, return 1
      if (Isotropic_growth_fct_pt == 0)
      {
        gamma = 1.0;
      }
      else
      {
        // Get isotropic growth
        (*Isotropic_growth_fct_pt)(xi, gamma);
      }
    }


    /// Evaluate body force at Lagrangian coordinate xi at present time
    /// (returns zero vector if no body force function pointer has been set)
    inline void body_force(const Vector<double>& xi, Vector<double>& b) const
    {
      // If no function has been set, return zero vector
      if (Body_force_fct_pt == 0)
      {
        // Get spatial dimension of element
        unsigned n = dim();
        for (unsigned i = 0; i < n; i++)
        {
          b[i] = 0.0;
        }
      }
      else
      {
        // Get time from timestepper of first node (note that this must
        // work -- body force only makes sense for elements that can be
        // deformed and given that the deformation of solid finite elements
        // is controlled by their nodes, nodes must exist!)
        double time = node_pt(0)->time_stepper_pt()->time_pt()->time();

        // Now evaluate the body force
        (*Body_force_fct_pt)(time, xi, b);
      }
    }


    /// returns the number of DOF types associated with this element.
    unsigned ndof_types() const
    {
      return DIM;
    }

    // /// Create a list of pairs for all unknowns in this element,
    // /// so that the first entry in each pair contains the global equation
    // /// number of the unknown, while the second one contains the number
    // /// of the "DOF" that this unknown is associated with.
    // /// (Function can obviously only be called if the equation numbering
    // /// scheme has been set up.)
    // /// E.g. in a 3D problem there are 3 types of DOF:
    // /// 0 - x displacement
    // /// 1 - y displacement
    // /// 2 - z displacement
    // void get_dof_numbers_for_unknowns(
    //   std::list<std::pair<unsigned long, unsigned>>& dof_lookup_list) const
    // {
    //   // temporary pair (used to store dof lookup prior to being added to
    //   // list
    //   std::pair<unsigned, unsigned> dof_lookup;

    //   // number of nodes
    //   const unsigned n_node = this->nnode();

    //   // Get the number of position dofs and dimensions at the node
    //   const unsigned n_position_type = nnodal_position_type();
    //   const unsigned nodal_dim = nodal_dimension();

    //   // Integer storage for local unknown
    //   int local_unknown = 0;

    //   // Loop over the nodes
    //   for (unsigned n = 0; n < n_node; n++)
    //   {
    //     // Loop over position dofs
    //     for (unsigned k = 0; k < n_position_type; k++)
    //     {
    //       // Loop over dimension
    //       for (unsigned i = 0; i < nodal_dim; i++)
    //       {
    //         // If the variable is free
    //         local_unknown = position_local_eqn(n, k, i);
    //           local_unknown =
    //             this->nodal_local_eqn(l, this->u_index_pvd(l, a,
    //             jth_solution));

    //         // ignore pinned values
    //         if (local_unknown >= 0)
    //         {
    //           // store dof lookup in temporary pair: First entry in pair
    //           // is global equation number; second entry is dof type
    //           dof_lookup.first = this->eqn_number(local_unknown);
    //           dof_lookup.second = i;

    //           // add to list
    //           dof_lookup_list.push_front(dof_lookup);
    //         }
    //       }
    //     }
    //   }
    // }

    /// Set Jacobian to be evaluated by FD? Else: Analytically.
    void enable_evaluate_jacobian_by_fd()
    {
      Evaluate_jacobian_by_fd = true;
    }

    /// Set Jacobian to be evaluated analytically Else: by FD
    void disable_evaluate_jacobian_by_fd()
    {
      Evaluate_jacobian_by_fd = false;
    }

    /// Return the flag indicating whether the jacobian is evaluated by fd
    bool is_jacobian_evaluated_by_fd() const
    {
      return Evaluate_jacobian_by_fd;
    }

    /// Return (i,j)-th component of second Piola Kirchhoff membrane
    /// prestress at Lagrangian coordinate xi
    double prestress(const unsigned& i,
                     const unsigned& j,
                     const Vector<double> xi)
    {
      if (Prestress_fct_pt == 0)
      {
        return 0.0;
      }
      else
      {
        return (*Prestress_fct_pt)(i, j, xi);
      }
    }

  protected:
    /// Pointer to isotropic growth function
    IsotropicGrowthFctPt Isotropic_growth_fct_pt;

    /// Pointer to prestress function
    PrestressFctPt Prestress_fct_pt;

    /// Pointer to the constitutive law
    ConstitutiveLaw* Constitutive_law_pt;

    /// Timescale ratio (non-dim. density)
    double* Lambda_sq_pt;

    /// Flag that switches inertia on/off
    bool Unsteady;

    /// Pointer to body force function
    BodyForceFctPt Body_force_fct_pt;

    /// Static default value for timescale ratio (1.0 -- for natural
    /// scaling)
    static double Default_lambda_sq_value;

    /// Use FD to evaluate Jacobian
    bool Evaluate_jacobian_by_fd;
  };


  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////


  //=======================================================================
  /// A class for elements that solve the equations of linear elasticity
  /// in cartesian coordinates.
  //=======================================================================
  template<unsigned DIM>
  class DecomposedPVDEquations : public virtual DecomposedPVDEquationsBase<DIM>
  {
  public:
    ///  Constructor
    DecomposedPVDEquations() {}

    /// Number of values required at node n.
    unsigned required_nvalue(const unsigned& n) const
    {
      return 2 * DIM;
    }

    /// Return the residuals for the solid equations (the discretised
    /// principle of virtual displacements)
    void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      fill_in_generic_contribution_to_residuals_pvd(
        residuals, GeneralisedElement::Dummy_matrix, 0);
    }

    /// The jacobian is calculated by finite differences by default,
    /// We need only to take finite differences w.r.t. positional variables
    /// For this element
    void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                          DenseMatrix<double>& jacobian)
    {
      if ((this->Evaluate_jacobian_by_fd))
      {
        FiniteElement::fill_in_contribution_to_jacobian(residuals, jacobian);
      }
      else
      {
        // Add the contribution to the residuals
        this->fill_in_generic_contribution_to_residuals_pvd(
          residuals, jacobian, 1);
      }
    }

    /// Output: x,y,[z],u,v,[w]
    void output(std::ostream& outfile)
    {
      unsigned n_plot = 3;
      output(outfile, n_plot);
    }

    /// Output: x,y,[z],u,v,[w]
    void output(std::ostream& outfile, const unsigned& n_plot);


    /// Private helper function to compute residuals and (if requested
    /// via flag) also the Jacobian matrix.
    virtual void fill_in_generic_contribution_to_residuals_pvd(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      const unsigned& flag);

  protected:
    /// Return the 2nd Piola Kirchhoff stress tensor, as
    /// calculated from the constitutive law: Pass metric tensors in the
    /// stress free and current configurations.
    inline void get_stress(const DenseMatrix<double>& g,
                           const DenseMatrix<double>& G,
                           DenseMatrix<double>& sigma)
    {
#ifdef PARANOID
      // If the pointer to the constitutive law hasn't been set, issue an
      // error
      if (this->Constitutive_law_pt == 0)
      {
        // Write an error message
        std::string error_message = "Elements derived from PVDEquations "
                                    "must have a constitutive law:\n";
        error_message +=
          "set one using the constitutive_law_pt() member function";
        // Throw the error
        throw OomphLibError(
          error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
      }
#endif
      this->Constitutive_law_pt->calculate_second_piola_kirchhoff_stress(
        g, G, sigma);
    }

    /// Return the derivatives of the 2nd Piola Kirchhoff stress tensor,
    /// as calculated from the constitutive law: Pass metric tensors in the
    /// stress free and current configurations and the current value of the
    /// the stress tensor.
    inline void get_d_stress_dG_upper(const DenseMatrix<double>& g,
                                      const DenseMatrix<double>& G,
                                      const DenseMatrix<double>& sigma,
                                      RankFourTensor<double>& d_sigma_dG)
    {
#ifdef PARANOID
      // If the pointer to the constitutive law hasn't been set, issue an
      // error
      if (this->Constitutive_law_pt == 0)
      {
        // Write an error message
        std::string error_message = "Elements derived from PVDEquations "
                                    "must have a constitutive law:\n";
        error_message +=
          "set one using the constitutive_law_pt() member function";
        // Throw the error
        throw OomphLibError(
          error_message, OOMPH_CURRENT_FUNCTION, OOMPH_EXCEPTION_LOCATION);
      }
#endif
      // Only bother with the symmetric part by passing false as last entry
      this->Constitutive_law_pt->calculate_d_second_piola_kirchhoff_stress_dG(
        g, G, sigma, d_sigma_dG, false);
    }

  private:
    /// Unpin all solid pressure dofs -- empty as there are no pressures
    void unpin_elemental_solid_pressure_dofs() {}
  };

} // namespace oomph

#endif
