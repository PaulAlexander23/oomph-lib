// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2023 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Header file for general linear elasticity elements

// Include guards to prevent multiple inclusion of the header
#ifndef OOMPH_DECOMPOSED_LINEAR_ELASTICITY_ELEMENTS_HEADER
#define OOMPH_DECOMPOSED_LINEAR_ELASTICITY_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif


// OOMPH-LIB headers
#include "generic.h"
#include "linear_elasticity.h"

namespace oomph
{
  //=======================================================================
  /// A base class for elements that solve the equations of linear
  /// elasticity in Cartesian coordinates.
  /// Combines a few generic functions that are shared by
  /// DecomposedLinearElasticityEquations
  /// and DecomposedLinearElasticityEquationsWithPressure (hierher: The latter
  /// don't exist yet but will be written as soon as somebody needs them...)
  //=======================================================================
  template<unsigned DIM>
  class DecomposedLinearElasticityEquationsBase : public virtual FiniteElement
  {
  public:
    /// Return the index at which the i-th unknown displacement
    /// component is stored. The default value, i, is appropriate for
    /// single-physics problems.
    virtual inline unsigned u_index_linear_elasticity(const unsigned& n,
                                                      const unsigned& i,
                                                      const unsigned& j) const
    {
      return i + DIM * j;
    }

    void pin_Xhat(const unsigned& n, const unsigned& i, const unsigned& j)
    {
      this->node_pt(n)->pin(u_index_linear_elasticity(n, i, j));
    }

    void set_value_Xhat(const unsigned& n,
                        const unsigned& i,
                        const unsigned& j,
                        const double& value)
    {
      this->node_pt(n)->set_value(u_index_linear_elasticity(n, i, j), value);
    }

    /// d^2u/dt^2 at local node n
    double d2u_dt2_linear_elasticity(const unsigned& n,
                                     const unsigned& i,
                                     const unsigned& j) const
    {
      // Get the timestepper
      TimeStepper* time_stepper_pt = node_pt(n)->time_stepper_pt();

      // Storage for the derivative - initialise to 0
      double d2u_dt2 = 0.0;

      // If we are doing an unsteady solve then calculate the derivative
      if (!time_stepper_pt->is_steady())
      {
        // Get the nodal index
        const unsigned u_nodal_index = u_index_linear_elasticity(n, i, j);

        // Get the number of values required to represent history
        const unsigned n_time = time_stepper_pt->ntstorage();

        // Loop over history values
        for (unsigned t = 0; t < n_time; t++)
        {
          // Add the contribution to the derivative
          d2u_dt2 +=
            time_stepper_pt->weight(2, t) * nodal_value(t, n, u_nodal_index);
        }
      }

      return d2u_dt2;
    }

    /// Compute vector of FE interpolated displacement u at local coordinate s
    void interpolated_u_linear_elasticity(const Vector<double>& s,
                                          const unsigned& j,
                                          Vector<double>& disp) const
    {
      // Find number of nodes
      unsigned n_node = nnode();

      // Local shape function
      Shape psi(n_node);

      // Find values of shape function
      shape(s, psi);

      for (unsigned i = 0; i < DIM; i++)
      {
        // Initialise value of u
        disp[i] = 0.0;

        // Loop over the local nodes and sum
        for (unsigned l = 0; l < n_node; l++)
        {
          // Index at which the nodal value is stored
          unsigned u_nodal_index = u_index_linear_elasticity(l, i, j);
          disp[i] += nodal_value(l, u_nodal_index) * psi[l];
        }
      }
    }

    /// Return FE interpolated displacement u[i] at local coordinate s
    double interpolated_u_linear_elasticity(const Vector<double>& s,
                                            const unsigned& i,
                                            const unsigned& j) const
    {
      // Find number of nodes
      unsigned n_node = nnode();

      // Local shape function
      Shape psi(n_node);

      // Find values of shape function
      shape(s, psi);


      // Initialise value of u
      double interpolated_u = 0.0;

      // Loop over the local nodes and sum
      for (unsigned l = 0; l < n_node; l++)
      {
        // Get nodal index at which i-th velocity is stored
        unsigned u_nodal_index = u_index_linear_elasticity(l, i, j);
        interpolated_u += nodal_value(l, u_nodal_index) * psi[l];
      }

      return (interpolated_u);
    }


    /// Function pointer to function that specifies the body force
    /// as a function of the Cartesian coordinates and time FCT(t,x,b) --
    /// x and b are  Vectors!
    typedef void (*BodyForceFctPt)(const double& t,
                                   const Vector<double>& x,
                                   Vector<double>& b);

    /// Constructor: Set null pointers for constitutive law and for
    /// isotropic growth function. Set physical parameter values to
    /// default values, switch on inertia and set body force to zero.
    DecomposedLinearElasticityEquationsBase()
      : Elasticity_tensor_pt(0),
        Lambda_sq_pt(&Default_lambda_sq_value),
        Unsteady(true),
        Body_force_fct_pt(0)
    {
    }

    /// Return the pointer to the elasticity_tensor
    ElasticityTensor*& elasticity_tensor_pt()
    {
      return Elasticity_tensor_pt;
    }

    /// Access function to the entries in the elasticity tensor
    inline double E(const unsigned& i,
                    const unsigned& j,
                    const unsigned& k,
                    const unsigned& l) const
    {
      return (*Elasticity_tensor_pt)(i, j, k, l);
    }

    /// Access function for timescale ratio (nondim density)
    const double& lambda_sq() const
    {
      return *Lambda_sq_pt;
    }

    /// Access function for pointer to timescale ratio (nondim density)
    double*& lambda_sq_pt()
    {
      return Lambda_sq_pt;
    }

    /// Access function: Pointer to body force function
    BodyForceFctPt& body_force_fct_pt()
    {
      return Body_force_fct_pt;
    }

    /// Access function: Pointer to body force function (const version)
    BodyForceFctPt body_force_fct_pt() const
    {
      return Body_force_fct_pt;
    }


    /// Switch on solid inertia
    void enable_inertia()
    {
      Unsteady = true;
    }

    /// Switch off solid inertia
    void disable_inertia()
    {
      Unsteady = false;
    }

    /// Access function to flag that switches inertia on/off (const version)
    bool is_inertia_enabled() const
    {
      return Unsteady;
    }

    /// Return the Cauchy stress tensor, as calculated
    /// from the elasticity tensor at specified local coordinate
    /// Virtual so separaete versions can (and must!) be provided
    /// for displacement and pressure-displacement formulations.
    virtual void get_stress(const Vector<double>& s,
                            const unsigned& jth_solution,
                            DenseMatrix<double>& sigma) const = 0;

    /// Return the strain tensor
    void get_strain(const Vector<double>& s,
                    const unsigned& jth_solution,
                    DenseMatrix<double>& strain) const;

    /// Evaluate body force at Eulerian coordinate x at present time
    /// (returns zero vector if no body force function pointer has been set)
    inline void body_force(const Vector<double>& x, Vector<double>& b) const
    {
      // If no function has been set, return zero vector
      if (Body_force_fct_pt == 0)
      {
        // Get spatial dimension of element
        unsigned n = dim();
        for (unsigned i = 0; i < n; i++)
        {
          b[i] = 0.0;
        }
      }
      else
      {
        // Get time from timestepper of first node (note that this must
        // work -- body force only makes sense for elements that can be
        // deformed and given that the deformation of solid finite elements
        // is controlled by their nodes, nodes must exist!)
        double time = node_pt(0)->time_stepper_pt()->time_pt()->time();

        // Now evaluate the body force
        (*Body_force_fct_pt)(time, x, b);
      }
    }


    /// The number of "DOF types" that degrees of freedom in this element
    /// are sub-divided into: for now lump them all into one DOF type.
    /// Can be adjusted later
    unsigned ndof_types() const
    {
      return 2;
      // return 1;
    }

  protected:
    /// Pointer to the elasticity tensor
    ElasticityTensor* Elasticity_tensor_pt;

    /// Timescale ratio (non-dim. density)
    double* Lambda_sq_pt;

    /// Flag that switches inertia on/off
    bool Unsteady;

    /// Pointer to body force function
    BodyForceFctPt Body_force_fct_pt;

    /// Static default value for timescale ratio (1.0 -- for natural scaling)
    static double Default_lambda_sq_value;
  };


  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////
  /// ////////////////////////////////////////////////////////////////////


  //=======================================================================
  /// A class for elements that solve the equations of linear elasticity
  /// in cartesian coordinates.
  //=======================================================================
  template<unsigned DIM>
  class DecomposedLinearElasticityEquations
    : public virtual DecomposedLinearElasticityEquationsBase<DIM>
  {
  public:
    ///  Constructor
    DecomposedLinearElasticityEquations() {}

    /// Number of values required at node n.
    unsigned required_nvalue(const unsigned& n) const
    {
      return 2 * DIM;
    }

    /// Return the residuals for the solid equations (the discretised
    /// principle of virtual displacements)
    void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      fill_in_generic_contribution_to_residuals_linear_elasticity(
        residuals, GeneralisedElement::Dummy_matrix, 0);
    }

    /// The jacobian is calculated by finite differences by default,
    /// We need only to take finite differences w.r.t. positional variables
    /// For this element
    void fill_in_contribution_to_jacobian(Vector<double>& residuals,
                                          DenseMatrix<double>& jacobian)
    {
      // Add the contribution to the residuals
      this->fill_in_generic_contribution_to_residuals_linear_elasticity(
        residuals, jacobian, 1);
    }

    /// Return the Cauchy stress tensor, as calculated
    /// from the elasticity tensor at specified local coordinate
    void get_stress(const Vector<double>& s,
                    const unsigned& j,
                    DenseMatrix<double>& sigma) const;


    /// Output exact solution x,y,[z],u,v,[w]
    void output_fct(std::ostream& outfile,
                    const unsigned& nplot,
                    FiniteElement::SteadyExactSolutionFctPt exact_soln_pt);

    /// Output exact solution x,y,[z],u,v,[w] (unsteady version)
    void output_fct(std::ostream& outfile,
                    const unsigned& nplot,
                    const double& time,
                    FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt);

    /// Output: x,y,[z],u,v,[w]
    void output(std::ostream& outfile)
    {
      unsigned n_plot = 5;
      output(outfile, n_plot);
    }

    /// Output: x,y,[z],u,v,[w]
    void output(std::ostream& outfile, const unsigned& n_plot);


    /// C-style output: x,y,[z],u,v,[w]
    void output(FILE* file_pt)
    {
      unsigned n_plot = 5;
      output(file_pt, n_plot);
    }

    /// Output: x,y,[z],u,v,[w]
    void output(FILE* file_pt, const unsigned& n_plot);

  protected:
    /// Private helper function to compute residuals and (if requested
    /// via flag) also the Jacobian matrix.
    virtual void fill_in_generic_contribution_to_residuals_linear_elasticity(
      Vector<double>& residuals, DenseMatrix<double>& jacobian, unsigned flag);
  };

} // namespace oomph

#endif
