// LIC// ====================================================================
// LIC// This file forms part of oomph-lib, the object-oriented,
// LIC// multi-physics finite-element library, available
// LIC// at http://www.oomph-lib.org.
// LIC//
// LIC// Copyright (C) 2006-2023 Matthias Heil and Andrew Hazel
// LIC//
// LIC// This library is free software; you can redistribute it and/or
// LIC// modify it under the terms of the GNU Lesser General Public
// LIC// License as published by the Free Software Foundation; either
// LIC// version 2.1 of the License, or (at your option) any later version.
// LIC//
// LIC// This library is distributed in the hope that it will be useful,
// LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
// LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// LIC// Lesser General Public License for more details.
// LIC//
// LIC// You should have received a copy of the GNU Lesser General Public
// LIC// License along with this library; if not, write to the Free Software
// LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
// LIC// 02110-1301  USA.
// LIC//
// LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
// LIC//
// LIC//====================================================================
// Header file for (one-dimensional) free surface elements
// Include guards, to prevent multiple includes
#ifndef OOMPH_PATRICKLINEARISED_INTERFACE_ELEMENTS_HEADER
#define OOMPH_PATRICKLINEARISED_INTERFACE_ELEMENTS_HEADER

// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

// oomph-lib includes
#include "generic.h"
#include "linearised_axisym_navier_stokes.h"
#include "overlaying_my_linear_element.h"

namespace oomph
{
  //========================================================================
  /// Base class establishing common interfaces and functions for all
  /// linearised axisymmetric fluid interface elements.
  //========================================================================
  template<class BULK_ELEMENT>
  class LinearisedAxisymmetricFluidInterfaceElement : public virtual FaceElement
  {
  private:
    /// Pointer to the Capillary number
    double* Ca_pt;

    /// Pointer to the Strouhal number
    double* St_pt;

    /// Pointer to azimuthal mode number k in e^ik(theta) decomposition
    int* Azimuthal_Mode_Number_pt;

    /// Static default value for the physical constants (zero)
    static double Default_Physical_Constant_Value;

    /// Static default value for the azimuthal mode number (zero)
    static int Default_Azimuthal_Mode_Number_Value;

  public:
    /// Index at which the i-th velocity component is stored.
    Vector<unsigned> U_index_interface;

  protected:
    /// The Data that contains the external  pressure is stored
    /// as external Data for the element. Which external Data item is it?
    /// (int so it can be initialised to -1, indicating that external
    /// pressure hasn't been set).
    int External_data_number_of_external_pressure;

    /// Pointer to the Data item that stores the external pressure
    Data* Pext_data_pt;

    /// Which of the values in Pext_data_pt stores the external pressure
    unsigned Index_of_external_pressure_value;

    /// Access function that returns the local equation number
    /// for the i-th kinematic equation (i=0,1) that corresponds to the n-th
    /// local node. This must be overloaded by specific interface elements
    /// and depends on the method for handing the free-surface deformation.
    virtual int kinematic_local_eqn(const unsigned& n, const unsigned& i) = 0;

    virtual void get_base_lagrange_multiplier(const double& time,
                                              const unsigned& ipt,
                                              const Vector<double>& x,
                                              double& result)
    {
      result = 0.0;
    }

    virtual void get_base_pressure(const double& time,
                                   const unsigned& ipt,
                                   const Vector<double>& x,
                                   double& result)
    {
      result = 0;
    } // End of overloaded get_base_flow_u function

    virtual double get_base_u(const Vector<double>& s, const unsigned& i) = 0;

    /// Access function that returns the local equation number
    /// for the i in {0 = R, 1 = Z}, j in {0 = C, 1 = S} displacement equation
    /// that corresponds to the n-th local node. This must be overloaded by
    /// specific interface elements and depends on the method for handing the
    /// free-surface deformation.
    virtual int displacement_local_eqn(const unsigned& n,
                                       const unsigned& i,
                                       const unsigned& j) = 0;

    /// Access function for the local equation number that
    /// corresponds to the external pressure.
    int pext_local_eqn()
    {
#ifdef PARANOID
      if (External_data_number_of_external_pressure < 0)
      {
        throw OomphLibError("No external pressure has been set\n",
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif
      return external_local_eqn(External_data_number_of_external_pressure,
                                Index_of_external_pressure_value);
    }

    virtual double lagrange_multiplier(const unsigned& n,
                                       const unsigned& i) = 0;

    virtual double Xhat(const unsigned& n,
                        const unsigned& i,
                        const unsigned& j) = 0;

    virtual double dXhatdt(const unsigned& n,
                           const unsigned& i,
                           const unsigned& j) = 0;

    // public:
    //  /// Hijack the kinematic condition at the nodes passed in the vector
    //  /// This is required so that contact-angle conditions can be applied
    //  /// by the LinearisedAxisymmetricFluidInterfaceEdgeElements.
    //  virtual void hijack_kinematic_conditions(
    //    const Vector<unsigned>& bulk_node_number) = 0;


  protected:
    /// Helper function to calculate the residuals and (if flag==true)
    /// the Jacobian -- this function only deals with part of the Jacobian.
    virtual void fill_in_generic_residual_contribution_interface(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      DenseMatrix<double>& mass_matrix,
      unsigned flag);

    /// Helper function to calculate the additional contributions
    /// to the jacobian. This will be overloaded by elements that
    /// require contributions to their underlying equations from surface
    /// integrals. The only example at the moment are elements that
    /// use the equations of elasticity to handle the deformation of the
    /// bulk elements. The shape functions, normal, integral weight,
    /// and jacobian are passed so that they do not have to be recalculated.
    virtual void add_additional_residual_contributions(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      const unsigned& flag,
      const Shape& psif,
      const DShape& dpsifds,
      const Vector<double>& interpolated_n,
      const double& r,
      const double& W,
      const double& J)
    {
    }

  public:
    /// Constructor, set the default values of the booleans and pointers (null)
    LinearisedAxisymmetricFluidInterfaceElement() : Pext_data_pt(0)
    {
      // Set all the physical parameter pointers to the default value of zero
      Ca_pt = &this->Default_Physical_Constant_Value;
      St_pt = &this->Default_Physical_Constant_Value;

      // Set the azimuthal mode number to default (zero)
      Azimuthal_Mode_Number_pt = &Default_Azimuthal_Mode_Number_Value;

      External_data_number_of_external_pressure = -1;
    }

    void set_external_pressure_data_pt(Data* const& external_pressure_data_pt,
                                       const unsigned& index)
    {
#ifdef PARANOID
      if (external_pressure_data_pt->nvalue() != 1)
      {
        std::ostringstream error_message;
        error_message
          << "External pressure Data must only contain a single value!\n"
          << "This one contains " << external_pressure_data_pt->nvalue()
          << std::endl;

        throw OomphLibError(error_message.str(),
                            OOMPH_CURRENT_FUNCTION,
                            OOMPH_EXCEPTION_LOCATION);
      }
#endif
      External_data_number_of_external_pressure =
        this->add_external_data(external_pressure_data_pt, true);
      Index_of_external_pressure_value = index;
      Pext_data_pt = external_pressure_data_pt;
    }

    /// Virtual function that specifies the surface tension as
    /// a function of local position within the element
    /// The default behaviour is a constant surface tension of value 1.0
    /// It is expected that this function will be overloaded in more
    /// specialised elements to incorporate variations in surface tension.
    virtual double sigma(const Vector<double>& s_local)
    {
      return 1.0;
    }

    /// Calculate the residuals by calling the generic residual contribution.
    void fill_in_contribution_to_residuals(Vector<double>& residuals)
    {
      // Add the residual contributions
      fill_in_generic_residual_contribution_interface(
        residuals,
        GeneralisedElement::Dummy_matrix,
        GeneralisedElement::Dummy_matrix,
        0);
    }

    /// Helper function to calculate the additional contributions
    /// to the resisuals and Jacobian that arise from specific node update
    /// strategies. This is called within the integration loop over the
    /// element (for efficiency) and therefore requires a fairly large
    /// number of input parameters:
    /// - the velocity shape functions and their derivatives w.r.t.
    ///   the local coordinates
    /// - the surface gradient and divergence of the velocity shape
    ///   functions
    /// - The local and Eulerian coordinates,
    /// - the outer unit normal,
    /// - the integration weight from the integration scheme
    /// - the Jacobian of the mapping between the local and global coordinates
    ///   along the element. (Note that in the axisymmmetric case this
    ///   includes the r term)!
    virtual void add_additional_residual_contributions_interface(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      const unsigned& flag,
      const Shape& psif,
      const DShape& dpsifds,
      const Vector<double>& s,
      const Vector<double>& interpolated_x,
      const Vector<double>& interpolated_t1,
      const double& w,
      const double& J)
    {
    }

    /// Return the value of the Capillary number
    const double& ca() const
    {
      return *Ca_pt;
    }

    /// Return a pointer to the Capillary number
    double*& ca_pt()
    {
      return Ca_pt;
    }

    /// Return the value of the Strouhal number
    const double& st() const
    {
      return *St_pt;
    }

    /// Return a pointer to the Strouhal number
    double*& st_pt()
    {
      return St_pt;
    }

    /// Azimuthal mode number k in e^ik(theta) decomposition
    const int& azimuthal_mode_number() const
    {
      return *Azimuthal_Mode_Number_pt;
    }

    /// Pointer to azimuthal mode number k in e^ik(theta) decomposition
    int*& azimuthal_mode_number_pt()
    {
      return Azimuthal_Mode_Number_pt;
    }

    /// Return the i-th velocity component at local node n
    /// The use of the array U_index_interface allows the velocity
    /// components to be stored in any location at the node.
    double u(const unsigned& n, const unsigned& i)
    {
      return node_pt(n)->value(U_index_interface[i]);
    }

    /// Calculate the i-th velocity component at the local coordinate s
    double interpolated_u(const Vector<double>& s, const unsigned& i)
    {
      // Find number of nodes
      const unsigned n_node = nnode();

      // Storage for the local shape function
      Shape psi(n_node);

      // Get values of shape function at local coordinate s
      this->shape(s, psi);

      // Initialise value of u
      double interpolated_u = 0.0;

      // Loop over the local nodes and sum
      for (unsigned l = 0; l < n_node; l++)
      {
        interpolated_u += u(l, i) * psi(l);
      }

      return (interpolated_u);
    }

    virtual double get_base_external_pressure()
    {
      return 0.0;
    }
  };

  //=======================================================================
  /// Physical constants default to zero
  //=======================================================================
  template<class BULK_ELEMENT>
  double LinearisedAxisymmetricFluidInterfaceElement<
    BULK_ELEMENT>::Default_Physical_Constant_Value = 1.0;

  //=======================================================================
  /// Azimuthal mode number defaults to zero
  //=======================================================================
  template<class BULK_ELEMENT>
  int LinearisedAxisymmetricFluidInterfaceElement<
    BULK_ELEMENT>::Default_Azimuthal_Mode_Number_Value = 0;

  //=======================================================================
  /// Calculate the residuals for the linearised axisymmetric
  /// interface element
  //=======================================================================
  template<class BULK_ELEMENT>
  void LinearisedAxisymmetricFluidInterfaceElement<BULK_ELEMENT>::
    fill_in_generic_residual_contribution_interface(
      Vector<double>& residuals,
      DenseMatrix<double>& jacobian,
      DenseMatrix<double>& mass_matrix,
      unsigned flag)
  {
    const bool is_using_normal_forcing_with_base = false;

    // Determine number of nodes in the element
    const unsigned n_node = this->nnode();

    // Set up memory for the shape functions and their derivative w.r.t. the
    // local coordinate s
    Shape psif(n_node);
    DShape dpsifds(n_node, 1);

    // Set up memory for the test functions and their derivative w.r.t. the
    // local coordinate s
    Shape testf(n_node);
    DShape dtestfds(n_node, 1);

    // Storage for the local coordinate
    Vector<double> s(1);

    // Storage for the local coordinate in the parent element which
    // corresponds to the local coordinate in this element
    Vector<double> s_parent(2);

    // Get a pointer to the parent element
    BULK_ELEMENT* bulk_el_pt = dynamic_cast<BULK_ELEMENT*>(bulk_element_pt());

    // Determine the number of nodes in the parent element
    const unsigned n_node_parent = bulk_el_pt->nnode();

    // Set up memory for the parent test functions and their derivatives
    Shape testf_parent(n_node_parent);
    DShape dtestfdx_parent(n_node_parent, 2);

    // Determine number of integration points
    const unsigned n_intpt = this->integral_pt()->nweight();

    // Get physical variables from the element
    const double Ca = ca();
    double St = st();
    const int k = azimuthal_mode_number();
    const double p_ext = -get_base_external_pressure();
    double tilde_p_ext = 0;
    if (External_data_number_of_external_pressure >= 0)
    {
      tilde_p_ext = external_data_pt(External_data_number_of_external_pressure)
                      ->value(Index_of_external_pressure_value);
    }

    // Integers used to store the local equation and unknown numbers
    int local_eqn = 0, local_unknown = 0;

    // Loop over the integration points
    for (unsigned ipt = 0; ipt < n_intpt; ipt++)
    {
      // Get the local coordinate at the integration point
      s[0] = integral_pt()->knot(ipt, 0);

      // Get the corresponding local coordinate in the parent (bulk) element
      this->get_local_coordinate_in_bulk(s, s_parent);

      // Get the integral weight
      const double w = this->integral_pt()->weight(ipt);

      // Call the derivatives of the shape function
      this->dshape_local_at_knot(ipt, psif, dpsifds);

      // Set test functions equal to shape functions
      testf = psif;
      dtestfds = dpsifds;

      // Find the test functions and derivatives of the parent
      (void)bulk_el_pt->dshape_eulerian(
        s_parent, testf_parent, dtestfdx_parent);

      // Define and zero the tangent Vectors
      Vector<double> interpolated_t1(2, 0.0);
      Vector<double> continuous_t1(2, 0.0);
      Vector<double> unit_normal(2, 0.0);
      Vector<double> interpolated_x(2, 0.0);
      Vector<double> interpolated_dx_dt(2, 0.0);

      Vector<double> interpolated_lagrange_multiplier(2, 0.0);

      // Provide storage for velocity unknowns
      // (only need four of them in these equations)
      double interpolated_UC = 0.0;
      double interpolated_US = 0.0;
      double interpolated_WC = 0.0;
      double interpolated_WS = 0.0;

      // Provide storage for perturbed positions
      double interpolated_RC = 0.0;
      double interpolated_RS = 0.0;
      double interpolated_ZC = 0.0;
      double interpolated_ZS = 0.0;

      // Provide storage for derivatives of perturbed positions w.r.t.
      // the local coordinate
      double interpolated_dRCds = 0.0;
      double interpolated_dRSds = 0.0;
      double interpolated_dZCds = 0.0;
      double interpolated_dZSds = 0.0;

      // Provide storage for derivatives of perturbed positions w.r.t.
      // time
      double interpolated_dRCdt = 0.0;
      double interpolated_dRSdt = 0.0;
      double interpolated_dZCdt = 0.0;
      double interpolated_dZSdt = 0.0;

      // Loop over the shape functions
      for (unsigned l = 0; l < n_node; l++)
      {
        // Cache the shape function and its derivative
        const double psif_ = psif(l);
        double dpsifds_ = dpsifds(l, 0);

        // Loop over directional components
        for (unsigned i = 0; i < 2; i++)
        {
          interpolated_x[i] += this->nodal_position(l, i) * psif_;
          interpolated_dx_dt[i] += this->dnodal_position_dt(l, i) * psif_;

          // Calculate the tangent vector
          interpolated_t1[i] += this->nodal_position(l, i) * dpsifds_;

          interpolated_lagrange_multiplier[i] +=
            this->lagrange_multiplier(l, i) * psif_;
        }

        // Calculate interpolated velocity components
        interpolated_UC += u(l, 0) * psif_;
        interpolated_US += u(l, 1) * psif_;
        interpolated_WC += u(l, 2) * psif_;
        interpolated_WS += u(l, 3) * psif_;

        interpolated_RC += this->Xhat(l, 0, 0) * psif_;
        interpolated_RS += this->Xhat(l, 0, 1) * psif_;
        interpolated_ZC += this->Xhat(l, 1, 0) * psif_;
        interpolated_ZS += this->Xhat(l, 1, 1) * psif_;

        interpolated_dRCds += this->Xhat(l, 0, 0) * dpsifds_;
        interpolated_dRSds += this->Xhat(l, 0, 1) * dpsifds_;
        interpolated_dZCds += this->Xhat(l, 1, 0) * dpsifds_;
        interpolated_dZSds += this->Xhat(l, 1, 1) * dpsifds_;

        interpolated_dRCdt += this->dXhatdt(l, 0, 0) * psif_;
        interpolated_dRSdt += this->dXhatdt(l, 0, 1) * psif_;
        interpolated_dZCdt += this->dXhatdt(l, 1, 0) * psif_;
        interpolated_dZSdt += this->dXhatdt(l, 1, 1) * psif_;
      }

      Vector<Vector<double>> tang_vec(1);
      tang_vec[0].resize(2, 0.0);
      continuous_tangent_and_outer_unit_normal(s, tang_vec, unit_normal);
      continuous_t1 = tang_vec[0];

      bool is_element_reversed = false;
      is_element_reversed = (continuous_t1[0] * interpolated_t1[0] +
                             continuous_t1[1] * interpolated_t1[1]) < 0;

      if (is_element_reversed)
      {
        interpolated_dRCds = -interpolated_dRCds;
        interpolated_dRSds = -interpolated_dRSds;
        interpolated_dZCds = -interpolated_dZCds;
        interpolated_dZSds = -interpolated_dZSds;
      }

      // Get velocities from base flow problem
      // -------------------------------------

      double base_pressure = 0.0;
      get_base_pressure(node_pt(0)->time_stepper_pt()->time(),
                        ipt,
                        interpolated_x,
                        base_pressure);

      double base_lagrange_multiplier = 0.0;
      if (is_using_normal_forcing_with_base)
      {
        get_base_lagrange_multiplier(node_pt(0)->time_stepper_pt()->time(),
                                     ipt,
                                     interpolated_x,
                                     base_lagrange_multiplier);
      }

      // Cache base flow velocities
      const double interpolated_ur = this->get_base_u(s, 0);
      const double interpolated_uz = this->get_base_u(s, 1);
      const double interpolated_utheta = this->get_base_u(s, 2);

      // The first positional coordinate is the radial coordinate
      const double r = interpolated_x[0];

      // Calculate the length of the tangent Vector
      const double tlength = interpolated_t1[0] * interpolated_t1[0] +
                             interpolated_t1[1] * interpolated_t1[1];

      // Set the Jacobian of the line element
      const double J = sqrt(tlength);
      // const double J = r * sqrt(tlength);
      // const double J = this->J_eulerian(s);

      // Normalise the tangent Vector
      // continuous_t1[0] /= J;
      // continuous_t1[1] /= J;

      // Also get the (possibly variable) surface tension
      const double Sigma = this->sigma(s);

      // Loop over the test functions
      for (unsigned l = 0; l < n_node; l++)
      {
        // Cache test function and its derivative
        const double testf_ = testf(l);
        double dtestfds_ = dtestfds(l, 0);
        if (is_element_reversed)
        {
          dtestfds_ = -dtestfds_;
        }

        // =================================================
        // START OF DYNAMIC BOUNDARY CONDITION CONTRIBUTIONS
        // =================================================

        // -------------------------------------------------------------
        // Contribution to first (radial) momentum equation: cosine part
        // -------------------------------------------------------------

        // Get local equation number of first velocity value at this node
        local_eqn = this->nodal_local_eqn(l, this->U_index_interface[0]);

        // If it's not a boundary condition
        if (local_eqn >= 0)
        {
          residuals[local_eqn] -=
            tilde_p_ext * unit_normal[0] * r * J * testf_ * w;
          residuals[local_eqn] +=
            p_ext *
            (continuous_t1[1] * interpolated_RC * J + r * interpolated_dZCds) *
            testf_ * w;
          residuals[local_eqn] -= (Sigma / Ca) *
                                  (continuous_t1[0] * interpolated_dRCds +
                                   continuous_t1[1] * interpolated_dZCds) *
                                  testf_ * w;
          residuals[local_eqn] -= (Sigma / Ca) *
                                  (continuous_t1[0] * interpolated_RC +
                                   r / J * continuous_t1[1] *
                                     (continuous_t1[1] * interpolated_dRCds -
                                      continuous_t1[0] * interpolated_dZCds)) *
                                  dtestfds_ * w;

          residuals[local_eqn] -= (Sigma / Ca) * k * k * J / r *
                                  continuous_t1[1] *
                                  (continuous_t1[1] * interpolated_RC -
                                   continuous_t1[0] * interpolated_ZC) *
                                  testf_ * w;


          // Calculate the Jacobian
          // ----------------------
          if (flag)
          {
            // Loop over the shape functions again
            for (unsigned l2 = 0; l2 < n_node; l2++)
            {
              // Cache the shape function and its derivative
              const double psif_ = psif(l2);
              double dpsifds_ = dpsifds(l2, 0);
              if (is_element_reversed)
              {
                dpsifds_ = -dpsifds_;
              }

              // Perturbed spine "height" (cosine part) H_k^C
              local_unknown = kinematic_local_eqn(l2, 0);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) +=
                  (Sigma / Ca) * continuous_t1[1] * dpsifds_ * testf_ * w;
                jacobian(local_eqn, local_unknown) -=
                  (Sigma / Ca) * r * r * continuous_t1[1] * continuous_t1[0] *
                  dpsifds_ * dtestfds_ * w / J;
                jacobian(local_eqn, local_unknown) -=
                  (Sigma / Ca) * k * k * J / r / r * continuous_t1[1] *
                  continuous_t1[0] * psif_ * testf_ * w;
              }

              // Perturbed spine "height" (sine part) H_K^S
              // has no contribution

              // Perturbed spine "height" (cosine part) H_k^C
              local_unknown =
                external_local_eqn(External_data_number_of_external_pressure,
                                   Index_of_external_pressure_value);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) -=
                  continuous_t1[1] * J * testf_ * w;
              }

            } // End of loop over shape functions
          } // End of Jacobian calculation
        } // End of if not boundary condition statement

        // ------------------------------------------------------------
        // Contribution to second (radial) momentum equation: sine part
        // ------------------------------------------------------------

        // Get local equation number of second velocity value at this node
        local_eqn = this->nodal_local_eqn(l, this->U_index_interface[1]);

        // If it's not a boundary condition
        if (local_eqn >= 0)
        {
          residuals[local_eqn] +=
            p_ext *
            (continuous_t1[1] * interpolated_RS * J + r * interpolated_dZSds) *
            testf_ * w;
          residuals[local_eqn] -= (Sigma / Ca) *
                                  (continuous_t1[0] * interpolated_dRSds +
                                   continuous_t1[1] * interpolated_dZSds) *
                                  testf_ * w;
          residuals[local_eqn] -= (Sigma / Ca) *
                                  (continuous_t1[0] * interpolated_RS +
                                   r / J * continuous_t1[1] *
                                     (continuous_t1[1] * interpolated_dRSds -
                                      continuous_t1[0] * interpolated_dZSds)) *
                                  dtestfds_ * w;
          residuals[local_eqn] -= (Sigma / Ca) * k * k * J / r *
                                  continuous_t1[1] *
                                  (continuous_t1[1] * interpolated_RS -
                                   continuous_t1[0] * interpolated_ZS) *
                                  testf_ * w;

          // Calculate the Jacobian
          // ----------------------
          if (flag)
          {
            // Loop over the shape functions again
            for (unsigned l2 = 0; l2 < n_node; l2++)
            {
              // Cache the shape function and its derivative
              const double psif_ = psif(l2);
              double dpsifds_ = dpsifds(l2, 0);
              if (is_element_reversed)
              {
                dpsifds_ = -dpsifds_;
              }

              // Perturbed spine "height" (cosine part) H_k^C
              // has no contribution

              // Perturbed spine "height" (sine part) H_K^S
              local_unknown = kinematic_local_eqn(l2, 1);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) +=
                  (Sigma / Ca) * continuous_t1[1] * dpsifds_ * testf_ * w;
                jacobian(local_eqn, local_unknown) -=
                  (Sigma / Ca) * r * r * continuous_t1[1] * continuous_t1[0] *
                  dpsifds_ * dtestfds_ * w / J;
                jacobian(local_eqn, local_unknown) -=
                  (Sigma / Ca) * k * k * J / r / r * continuous_t1[1] *
                  continuous_t1[0] * psif_ * testf_ * w;
              }
            } // End of loop over shape functions
          } // End of Jacobian calculation
        } // End of if not boundary condition statement

        // ------------------------------------------------------------
        // Contribution to third (axial) momentum equation: cosine part
        // ------------------------------------------------------------

        // Get local equation number of third velocity value at this node
        local_eqn = this->nodal_local_eqn(l, this->U_index_interface[2]);

        // If it's not a boundary condition
        if (local_eqn >= 0)
        {
          residuals[local_eqn] -=
            tilde_p_ext * unit_normal[1] * r * J * testf_ * w;
          residuals[local_eqn] -=
            p_ext *
            (continuous_t1[0] * interpolated_RC * J + r * interpolated_dRCds) *
            testf_ * w;

          residuals[local_eqn] -= (Sigma / Ca) *
                                  (continuous_t1[1] * interpolated_RC +
                                   r / J * continuous_t1[0] *
                                     (continuous_t1[0] * interpolated_dZCds -
                                      continuous_t1[1] * interpolated_dRCds)) *
                                  dtestfds_ * w;

          residuals[local_eqn] -= (Sigma / Ca) * k * k * J / r *
                                  continuous_t1[0] *
                                  (continuous_t1[0] * interpolated_ZC -
                                   continuous_t1[1] * interpolated_RC) *
                                  testf_ * w;

          // Calculate the Jacobian
          // ----------------------
          if (flag)
          {
            // Loop over the shape functions again
            for (unsigned l2 = 0; l2 < n_node; l2++)
            {
              // Cache the shape function and its derivative
              const double psif_ = psif(l2);
              double dpsifds_ = dpsifds(l2, 0);
              if (is_element_reversed)
              {
                dpsifds_ = -dpsifds_;
              }

              // Perturbed spine "height" (cosine part) H_k^C
              local_unknown = kinematic_local_eqn(l2, 0);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) +=
                  (Sigma / Ca) * r * r * continuous_t1[0] * continuous_t1[0] *
                  dpsifds_ * dtestfds_ * w / J;
                jacobian(local_eqn, local_unknown) +=
                  (Sigma / Ca) * k * k * J / r / r * continuous_t1[0] *
                  continuous_t1[0] * psif_ * testf_ * w;
              }

              // Perturbed spine "height" (sine part) H_K^S
              // has no contribution

              // Perturbed external pressure
              local_unknown =
                external_local_eqn(External_data_number_of_external_pressure,
                                   Index_of_external_pressure_value);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) +=
                  continuous_t1[0] * J * testf_ * w;
              }

            } // End of loop over shape functions
          } // End of Jacobian calculation
        } // End of if not boundary condition statement

        // -----------------------------------------------------------
        // Contribution to fourth (axial) momentum equation: sine part
        // -----------------------------------------------------------

        // Get local equation number of fourth velocity value at this node
        local_eqn = this->nodal_local_eqn(l, this->U_index_interface[3]);

        // If it's not a boundary condition
        if (local_eqn >= 0)
        {
          residuals[local_eqn] -=
            p_ext *
            (continuous_t1[0] * interpolated_RS * J + r * interpolated_dRSds) *
            testf_ * w;

          residuals[local_eqn] -= (Sigma / Ca) *
                                  (continuous_t1[1] * interpolated_RS +
                                   r / J * continuous_t1[0] *
                                     (continuous_t1[0] * interpolated_dZSds -
                                      continuous_t1[1] * interpolated_dRSds)) *
                                  dtestfds_ * w;

          residuals[local_eqn] -= (Sigma / Ca) * k * k * J / r *
                                  continuous_t1[0] *
                                  (continuous_t1[0] * interpolated_ZS -
                                   continuous_t1[1] * interpolated_RS) *
                                  testf_ * w;

          // Calculate the Jacobian
          // ----------------------
          if (flag)
          {
            // Loop over the shape functions again
            for (unsigned l2 = 0; l2 < n_node; l2++)
            {
              // Cache the shape function and its derivative
              const double psif_ = psif(l2);
              double dpsifds_ = dpsifds(l2, 0);
              if (is_element_reversed)
              {
                dpsifds_ = -dpsifds_;
              }

              // Perturbed spine "height" (cosine part) H_k^C
              // has no contribution

              // Perturbed spine "height" (sine part) H_K^S
              local_unknown = kinematic_local_eqn(l2, 1);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) +=
                  (Sigma / Ca) * r * r * continuous_t1[0] * continuous_t1[0] *
                  dpsifds_ * dtestfds_ * w / J;
                jacobian(local_eqn, local_unknown) +=
                  (Sigma / Ca) * k * k * J / r / r * continuous_t1[0] *
                  continuous_t1[0] * psif_ * testf_ * w;
              }
            } // End of loop over shape functions
          } // End of Jacobian calculation
        } // End of if not boundary condition statement

        // ----------------------------------------------------------------
        // Contribution to fifth (azimuthal) momentum equation: cosine part
        // ----------------------------------------------------------------

        // Get local equation number of fifth velocity value at this node
        local_eqn = this->nodal_local_eqn(l, this->U_index_interface[4]);

        // If it's not a boundary condition
        if (local_eqn >= 0)
        {
          residuals[local_eqn] += k * p_ext * J *
                                  (continuous_t1[0] * interpolated_ZS -
                                   continuous_t1[1] * interpolated_RS) *
                                  testf_ * w;
          residuals[local_eqn] -= (Sigma / Ca) * 2.0 * k * J /
                                  (r)*continuous_t1[1] *
                                  (continuous_t1[0] * interpolated_ZS -
                                   continuous_t1[1] * interpolated_RS) *
                                  testf_ * w;
          residuals[local_eqn] += (Sigma / Ca) * k *
                                  (continuous_t1[0] * interpolated_RS +
                                   continuous_t1[1] * interpolated_ZS) *
                                  dtestfds_ * w;
          residuals[local_eqn] +=
            (Sigma / Ca) * k *
            (continuous_t1[0] * interpolated_dRSds +
             continuous_t1[1] * interpolated_dZSds - interpolated_RS / r * J) *
            testf_ * w;

          // Calculate the Jacobian
          // ----------------------
          if (flag)
          {
            // Loop over the shape functions again
            for (unsigned l2 = 0; l2 < n_node; l2++)
            {
              // Cache the shape function and its derivative
              const double psif_ = psif(l2);
              double dpsifds_ = dpsifds(l2, 0);
              if (is_element_reversed)
              {
                dpsifds_ = -dpsifds_;
              }

              // Perturbed spine "height" (cosine part) H_k^C
              // has no contribution

              // Perturbed spine "height" (sine part) H_K^S
              local_unknown = kinematic_local_eqn(l2, 1);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) +=
                  (Sigma / Ca) * 2.0 * k * J / r * continuous_t1[1] *
                  continuous_t1[0] * psif_ * testf_ * w / (r * r);
                jacobian(local_eqn, local_unknown) -= (Sigma / Ca) * k *
                                                      continuous_t1[1] * psif_ *
                                                      dtestfds_ * w / r;
                jacobian(local_eqn, local_unknown) -= (Sigma / Ca) * k *
                                                      continuous_t1[1] *
                                                      dpsifds_ * testf_ * w / r;
              }
            } // End of loop over shape functions
          } // End of Jacobian calculation
        } // End of if not boundary condition statement

        // --------------------------------------------------------------
        // Contribution to sixth (azimuthal) momentum equation: sine part
        // --------------------------------------------------------------

        // Get local equation number of sixth velocity value at this node
        local_eqn = this->nodal_local_eqn(l, this->U_index_interface[5]);

        // If it's not a boundary condition
        if (local_eqn >= 0)
        {
          residuals[local_eqn] += k * p_ext * J *
                                  (continuous_t1[1] * interpolated_RC -
                                   continuous_t1[0] * interpolated_ZC) *
                                  testf_ * w;
          residuals[local_eqn] -= (Sigma / Ca) * 2.0 * k * J /
                                  (r)*continuous_t1[1] *
                                  (continuous_t1[1] * interpolated_RC -
                                   continuous_t1[0] * interpolated_ZC) *
                                  testf_ * w;
          residuals[local_eqn] -= (Sigma / Ca) * k *
                                  (continuous_t1[0] * interpolated_RC +
                                   continuous_t1[1] * interpolated_ZC) *
                                  dtestfds_ * w;
          residuals[local_eqn] -=
            (Sigma / Ca) * k *
            (continuous_t1[0] * interpolated_dRCds +
             continuous_t1[1] * interpolated_dZCds - interpolated_RC / r * J) *
            testf_ * w;

          // Calculate the Jacobian
          // ----------------------
          if (flag)
          {
            // Loop over the shape functions again
            for (unsigned l2 = 0; l2 < n_node; l2++)
            {
              // Cache the shape function and its derivative
              const double psif_ = psif(l2);
              double dpsifds_ = dpsifds(l2, 0);
              if (is_element_reversed)
              {
                dpsifds_ = -dpsifds_;
              }

              // Perturbed spine "height" (cosine part) H_k^C
              local_unknown = kinematic_local_eqn(l2, 0);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) -=
                  (Sigma / Ca) * 2.0 * k * J / r * continuous_t1[1] *
                  continuous_t1[0] * psif_ * testf_ * w / (r * r);
                jacobian(local_eqn, local_unknown) += (Sigma / Ca) * k *
                                                      continuous_t1[1] * psif_ *
                                                      dtestfds_ * w / r;
                jacobian(local_eqn, local_unknown) += (Sigma / Ca) * k *
                                                      continuous_t1[1] *
                                                      dpsifds_ * testf_ * w / r;
              }

              // Perturbed spine "height" (sine part) H_K^S
              // has no contribution

            } // End of loop over shape functions
          } // End of Jacobian calculation
        } // End of if not boundary condition statement

        // ===================================================
        // START OF KINEMATIC BOUNDARY CONDITION CONTRIBUTIONS
        // ===================================================

        // Using the same shape functions for the spines, so can stay inside
        // the loop over test functions

        // ------------------------------------------------
        // First kinematic boundary condition (cosine part)
        // ------------------------------------------------

        // Get local equation number of first perturbed spine "height"
        // (this is the cosine part H_k^C)
        local_eqn = kinematic_local_eqn(l, 0);

        // If the spine is not a boundary condition
        if (local_eqn >= 0)
        {
          residuals[local_eqn] +=
            continuous_t1[1] *
            (r * interpolated_UC + interpolated_ur * interpolated_RC) * testf_ *
            w * J;

          residuals[local_eqn] -=
            continuous_t1[0] *
            (r * interpolated_WC + interpolated_uz * interpolated_RC) * testf_ *
            w * J;

          residuals[local_eqn] -=
            St * continuous_t1[1] *
            (r * interpolated_dRCdt + interpolated_dx_dt[0] * interpolated_RC) *
            testf_ * w * J;

          residuals[local_eqn] +=
            St * continuous_t1[0] *
            (r * interpolated_dZCdt + interpolated_dx_dt[1] * interpolated_RC) *
            testf_ * w * J;

          residuals[local_eqn] -= k * interpolated_utheta *
                                  (continuous_t1[1] * interpolated_RS -
                                   continuous_t1[0] * interpolated_ZS) *
                                  testf_ * w * J;

          residuals[local_eqn] +=
            r * (interpolated_ur - St * interpolated_dx_dt[0]) *
            interpolated_dZCds * testf_ * w;

          residuals[local_eqn] -=
            r * (interpolated_uz - St * interpolated_dx_dt[1]) *
            interpolated_dRCds * testf_ * w;

          // Calculate the Jacobian
          // ----------------------
          if (flag)
          {
            // Loop over the shape functions again
            for (unsigned l2 = 0; l2 < n_node; l2++)
            {
              // Cache the shape function and its derivative
              const double psif_ = psif(l2);
              double dpsifds_ = dpsifds(l2, 0);
              if (is_element_reversed)
              {
                dpsifds_ = -dpsifds_;
              }

              // Radial velocity component (cosine part) U_k^C
              local_unknown = this->nodal_local_eqn(l2, U_index_interface[0]);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) -=
                  r * continuous_t1[1] * psif_ * testf_ * w * J;
              }

              // Axial velocity component (cosine part) W_k^C
              local_unknown = nodal_local_eqn(l2, U_index_interface[2]);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) +=
                  r * continuous_t1[0] * psif_ * testf_ * w * J;
              }

              // Perturbed spine "height" (cosine part) H_k^C
              local_unknown = kinematic_local_eqn(l2, 0);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) -=
                  r * interpolated_ur * dpsifds_ * testf_ * w;

                jacobian(local_eqn, local_unknown) -=
                  St * r * continuous_t1[0] *
                  node_pt(l2)->time_stepper_pt()->weight(1, 0) * psif_ *
                  testf_ * w * J;
              }

              // Perturbed spine "height" (sine part) H_k^S
              local_unknown = kinematic_local_eqn(l2, 1);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) -= k * interpolated_utheta *
                                                      continuous_t1[0] * psif_ *
                                                      testf_ * w * J;
              }

            } // End of loop over shape functions
          } // End of Jacobian contribution

          if (flag == 2)
          {
            // Loop over the shape functions again
            for (unsigned l2 = 0; l2 < n_node; l2++)
            {
              // Cache the shape function and its derivative
              const double psif_ = psif(l2);

              // Radial velocity component (cosine part) U_k^C
              local_unknown = this->displacement_local_eqn(l2, 0, 0);
              if (local_unknown >= 0)
              {
                mass_matrix(local_eqn, local_unknown) -=
                  St * unit_normal[0] * psif_ * testf_ * w * J;
              }
              local_unknown = this->displacement_local_eqn(l2, 1, 0);
              if (local_unknown >= 0)
              {
                mass_matrix(local_eqn, local_unknown) -=
                  St * unit_normal[1] * psif_ * testf_ * w * J;
              }
            } // End of loop over shape functions
          }

          // -----------------------------------------------
          // First displacement Lagrange multiplier forcing
          // -----------------------------------------------

          double dpsifds_ = dpsifds(l, 0);
          if (is_element_reversed)
          {
            dpsifds_ = -dpsifds_;
          }
          double dt = node_pt(l)->time_stepper_pt()->weight(1, 0);
          if (dt == 0.0)
          {
            dt = 1.0;
          }

          // Get local equation number of second perturbed spine "height"
          // (this is the cosine part H_k^S)
          local_eqn = displacement_local_eqn(l, 0, 0);
          if (local_eqn >= 0)
          {
            residuals[local_eqn] -= interpolated_lagrange_multiplier[0] *
                                    unit_normal[0] * testf_ * J * w;

            residuals[local_eqn] += base_lagrange_multiplier *
                                    (interpolated_dRCds * unit_normal[0] +
                                     interpolated_dZCds * unit_normal[1]) *
                                    continuous_t1[0] * testf_ * w;
          }


          local_eqn = displacement_local_eqn(l, 1, 0);
          if (local_eqn >= 0)
          {
            residuals[local_eqn] -= interpolated_lagrange_multiplier[0] *
                                    unit_normal[1] * testf_ * J * w;

            residuals[local_eqn] += base_lagrange_multiplier *
                                    (interpolated_dRCds * unit_normal[0] +
                                     interpolated_dZCds * unit_normal[1]) *
                                    continuous_t1[1] * testf_ * w;
          }
        } // End of if not boundary condition statement

        // -----------------------------------------------
        // Second kinematic boundary condition (sine part)
        // -----------------------------------------------

        // Get local equation number of second perturbed spine "height"
        // (this is the sine part H_k^S)
        local_eqn = kinematic_local_eqn(l, 1);

        // If the spine is not a boundary condition
        if (local_eqn >= 0)
        {
          residuals[local_eqn] +=
            continuous_t1[1] *
            (r * interpolated_US + interpolated_ur * interpolated_RS) * testf_ *
            w * J;

          residuals[local_eqn] -=
            continuous_t1[0] *
            (r * interpolated_WS + interpolated_uz * interpolated_RS) * testf_ *
            w * J;

          residuals[local_eqn] -=
            St * continuous_t1[1] *
            (r * interpolated_dRSdt + interpolated_dx_dt[0] * interpolated_RS) *
            testf_ * w * J;

          residuals[local_eqn] +=
            St * continuous_t1[0] *
            (r * interpolated_dZSdt + interpolated_dx_dt[1] * interpolated_RS) *
            testf_ * w * J;

          residuals[local_eqn] += k * interpolated_utheta *
                                  (continuous_t1[1] * interpolated_RC -
                                   continuous_t1[0] * interpolated_ZC) *
                                  testf_ * w * J;

          residuals[local_eqn] +=
            r * (interpolated_ur - St * interpolated_dx_dt[0]) *
            interpolated_dZSds * testf_ * w;

          residuals[local_eqn] -=
            r * (interpolated_uz - St * interpolated_dx_dt[1]) *
            interpolated_dRSds * testf_ * w;

          // Add in the jacobian
          if (flag)
          {
            // Loop over velocity shape functions
            for (unsigned l2 = 0; l2 < n_node; l2++)
            {
              // Cache the shape function and its derivative
              const double psif_ = psif(l2);
              double dpsifds_ = dpsifds(l2, 0);
              if (is_element_reversed)
              {
                dpsifds_ = -dpsifds_;
              }

              // Radial velocity component (sine part) U_k^S
              local_unknown = this->nodal_local_eqn(l2, U_index_interface[1]);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) -=
                  r * continuous_t1[1] * psif_ * testf_ * w * J;
              }

              // Axial velocity component (sine part) W_k^S
              local_unknown = nodal_local_eqn(l2, U_index_interface[3]);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) +=
                  r * continuous_t1[0] * psif_ * testf_ * w * J;
              }

              // Perturbed spine "height" (cosine part) H_k^C
              local_unknown = kinematic_local_eqn(l2, 0);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) += k * interpolated_utheta *
                                                      continuous_t1[0] * psif_ *
                                                      testf_ * w * J;
              }

              // Perturbed spine "height" (sine part) H_k^S
              local_unknown = kinematic_local_eqn(l2, 1);
              if (local_unknown >= 0)
              {
                jacobian(local_eqn, local_unknown) -=
                  r * interpolated_ur * dpsifds_ * testf_ * w;

                jacobian(local_eqn, local_unknown) -=
                  St * r * continuous_t1[0] *
                  node_pt(l2)->time_stepper_pt()->weight(1, 0) * psif_ *
                  testf_ * w * J;
              }

            } // End of loop over shape functions
          } // End of Jacobian contribution

          if (flag == 2)
          {
            // Loop over the shape functions again
            for (unsigned l2 = 0; l2 < n_node; l2++)
            {
              // Cache the shape function and its derivative
              const double psif_ = psif(l2);

              // Radial velocity component (cosine part) U_k^C
              local_unknown = this->displacement_local_eqn(l2, 0, 1);
              if (local_unknown >= 0)
              {
                mass_matrix(local_eqn, local_unknown) -=
                  St * continuous_t1[1] * psif_ * testf_ * w * J;
              }
              local_unknown = this->displacement_local_eqn(l2, 1, 1);
              if (local_unknown >= 0)
              {
                mass_matrix(local_eqn, local_unknown) +=
                  St * continuous_t1[0] * psif_ * testf_ * w * J;
              }
            } // End of loop over shape functions
          }

          // -----------------------------------------------
          // Second displacement Lagrange multiplier forcing
          // -----------------------------------------------
          double dpsifds_ = dpsifds(l, 0);
          if (is_element_reversed)
          {
            dpsifds_ = -dpsifds_;
          }
          double dt = node_pt(l)->time_stepper_pt()->weight(1, 0);
          if (dt == 0.0)
          {
            dt = 1.0;
          }

          // Get local equation number of second perturbed spine "height"
          // (this is the sine part H_k^S)
          local_eqn = displacement_local_eqn(l, 0, 1);
          if (local_eqn >= 0)
          {
            residuals[local_eqn] -= interpolated_lagrange_multiplier[1] *
                                    unit_normal[0] * testf_ * J * w;

            residuals[local_eqn] += base_lagrange_multiplier *
                                    (interpolated_dRSds * unit_normal[0] +
                                     interpolated_dZSds * unit_normal[1]) *
                                    continuous_t1[0] * testf_ * w;
          }


          local_eqn = displacement_local_eqn(l, 1, 1);
          if (local_eqn >= 0)
          {
            residuals[local_eqn] -= interpolated_lagrange_multiplier[1] *
                                    unit_normal[1] * testf_ * J * w;

            residuals[local_eqn] += base_lagrange_multiplier *
                                    (interpolated_dRSds * unit_normal[0] +
                                     interpolated_dZSds * unit_normal[1]) *
                                    continuous_t1[1] * testf_ * w;
          }
        } // End of if not boundary condition statement
      } // End of loop over test functions

      add_additional_residual_contributions_interface(residuals,
                                                      jacobian,
                                                      flag,
                                                      psif,
                                                      dpsifds,
                                                      s,
                                                      interpolated_x,
                                                      continuous_t1,
                                                      w,
                                                      J);
    } // End of loop over integration points
  }

  //   //========================================================================
  //   /// Linearised axisymmetric interface elements that are used with a
  //   /// spine mesh, i.e. the mesh deformation is handled by Kistler &
  //   /// Scriven's "method of spines". These elements are FaceElements of bulk
  //   /// Fluid elements and the particular type of fluid element is passed
  //   /// as a template parameter to the element. It
  //   /// shouldn't matter whether the passed
  //   /// element is the underlying (fixed) element or the templated
  //   /// SpineElement<Element>.
  //   /// In the case of steady problems, an additional volume constaint
  //   /// must be imposed to select a particular solution from an otherwise
  //   /// inifinte number. This constraint is associated with an external
  //   /// pressure degree of freedom, which must be passed to the element as
  //   /// external data. If the element is a free surface, Free_surface = true,
  //   /// then the external pressure is the pressure in the inviscid external
  //   /// fluid; otherwise, the pressure degree of freedom must be passed from
  //   /// an element in the adjoining fluid.
  //   //========================================================================
  //   template<class ELEMENT>
  //   class PerturbedSpineLinearisedAxisymmetricFluidInterfaceElement
  //     : public virtual
  //     Hijacked<PerturbedSpineElement<FaceGeometry<ELEMENT>>>,
  //       public virtual LinearisedAxisymmetricFluidInterfaceElement
  //   {
  //   private:
  //     /// In these elements, the kinematic condition is the equation
  //     /// used to determine the "order epsilon" contributions to the free
  //     surface
  //     /// "height". We have two sets of unknowns, HC and HS, and we therefore
  //     have
  //     /// two kinematic conditions. Overload the function accordingly.
  //     int kinematic_local_eqn(const unsigned& n, const unsigned& i)
  //     {
  //       return this->spine_local_eqn(n, i);
  //     }
  //
  //
  //     /// Hijacking the kinematic condition corresponds to hijacking the
  //     /// spine heights.
  //     void hijack_kinematic_conditions(const Vector<unsigned>&
  //     bulk_node_number)
  //     {
  //       // Loop over all the passed nodes
  //       for (Vector<unsigned>::const_iterator it = bulk_node_number.begin();
  //            it != bulk_node_number.end();
  //            ++it)
  //       {
  //         // Hijack the spine heights and delete the returned data objects
  //         delete this->hijack_nodal_spine_value(*it, 0);
  //       }
  //     }
  //
  //     /// i-th component of dH/dt at local node n.
  //     /// Uses suitably interpolated value for hanging nodes.
  //     double dH_dt(const unsigned& n, const unsigned& i) const
  //     {
  //       // Get the data's timestepper
  //       TimeStepper* time_stepper_pt = this->node_pt(n)->time_stepper_pt();
  //
  //       // Upcast from general node to PerturbedSpineNode
  //       PerturbedSpineNode* perturbed_spine_node_pt =
  //         dynamic_cast<PerturbedSpineNode*>(this->node_pt(n));
  //
  //       // Initialise dH/dt
  //       double dHdt = 0.0;
  //
  //       // Loop over the timesteps, if there is a non Steady timestepper
  //       if (!time_stepper_pt->is_steady())
  //       {
  //         // Number of timsteps (past & present)
  //         const unsigned n_time = time_stepper_pt->ntstorage();
  //
  //         // Add the contributions to the time derivative
  //         for (unsigned t = 0; t < n_time; t++)
  //         {
  //           dHdt += time_stepper_pt->weight(1, t) *
  //                   perturbed_spine_node_pt->perturbed_spine_pt()->height(t,
  //                   i);
  //         }
  //       }
  //
  //       return dHdt;
  //     }
  //
  //   public:
  //     /// Constructor, the arguments are a pointer to the  "bulk" element
  //     /// the local coordinate that is fixed on the face, and
  //     /// whether it is the upper or lower limit of that coordinate.
  //     PerturbedSpineLinearisedAxisymmetricFluidInterfaceElement(
  //       FiniteElement* const& bulk_element_pt, const int& face_index)
  //       : Hijacked<PerturbedSpineElement<FaceGeometry<ELEMENT>>>(),
  //         LinearisedAxisymmetricFluidInterfaceElement()
  //     {
  //       // Attach the geometrical information to the element
  //       bulk_element_pt->build_face_element(face_index, this);
  //
  //       // Find the index at which the velocity unknowns are stored
  //       // from the bulk element
  //       ELEMENT* cast_element_pt = dynamic_cast<ELEMENT*>(bulk_element_pt);
  //
  //       // We must have six velocity components
  //       this->U_index_interface.resize(6);
  //       for (unsigned i = 0; i < 6; i++)
  //       {
  //         this->U_index_interface[i] =
  //         cast_element_pt->u_index_lin_axi_nst(i);
  //       }
  //
  //       // We must have four components of the perturbations to the
  //       // nodal positions
  //       this->Xhat_index_interface.resize(4);
  //       for (unsigned i = 0; i < 4; i++)
  //       {
  //         this->Xhat_index_interface[i] =
  //           cast_element_pt->xhat_index_lin_axi_nst(i);
  //       }
  //     }
  //
  //     /// Return the jacobian
  //     void fill_in_contribution_to_jacobian(Vector<double>& residuals,
  //                                           DenseMatrix<double>& jacobian)
  //     {
  //       // Call the generic residuals routine with the flag set to 1
  //       fill_in_generic_residual_contribution_interface(residuals, jacobian,
  //       1);
  //       // Call the generic routine to handle the spine variables
  //       // PerturbedSpineElement<FaceGeometry<ELEMENT> >::
  //       this->fill_in_jacobian_from_geometric_data(jacobian);
  //     }
  //
  //     /// This function is sort-of-hacky: its purpose is to overload the
  //     /// fill_in_generic_residual_contribution_interface(..) function in the
  //     /// LinearisedAxisymmetricFluidInterfaceElement base class, since I
  //     have
  //     /// made the maths too general and assumed not only spines but spines
  //     /// which always point vertically. When this is done properly this
  //     /// function should be removed so that the function in the base class
  //     /// is used, and that function should be implemented with the proper
  //     /// general maths which does not assume spines or anything.
  //     void fill_in_generic_residual_contribution_interface(
  //       Vector<double>& residuals, DenseMatrix<double>& jacobian, unsigned
  //       flag);
  //
  //     /// Overload the output function
  //     void output(std::ostream& outfile)
  //     {
  //       FiniteElement::output(outfile);
  //     }
  //
  //     /// Output the element
  //     void output(std::ostream& outfile, const unsigned& n_plot)
  //     {
  //       LinearisedAxisymmetricFluidInterfaceElement::output(outfile, n_plot);
  //     }
  //
  //     /// Overload the C-style output function
  //     void output(FILE* file_pt)
  //     {
  //       FiniteElement::output(file_pt);
  //     }
  //
  //     /// C-style Output function: x,y,[z],u,v,[w],p in tecplot format
  //     void output(FILE* file_pt, const unsigned& n_plot)
  //     {
  //       LinearisedAxisymmetricFluidInterfaceElement::output(file_pt, n_plot);
  //     }
  //
  //     /// Output just the interface position (base + perturbation)
  //     void output_interface_position(std::ostream& outfile,
  //                                    const unsigned& nplot);
  //
  //     /// Output the perturbation to the interface position
  //     void output_perturbation_to_interface(std::ostream& outfile,
  //                                           const unsigned& nplot);
  //
  //     /// Return the i-th component of the FE interpolated perturbed
  //     /// surface height (i=0 is cosine part, i=1 is sine part) at local
  //     /// coordinate s
  //     double interpolated_H(const Vector<double>& s, const unsigned& i) const
  //     {
  //       // Determine number of nodes in the element
  //       const unsigned n_node = nnode();
  //
  //       // Provide storage for local shape functions
  //       Shape psi(n_node);
  //
  //       // Find values of shape functions
  //       shape(s, psi);
  //
  //       // Initialise value of H
  //       double interpolated_H = 0.0;
  //
  //       // Loop over the shape functions and sum
  //       for (unsigned l = 0; l < n_node; l++)
  //       {
  //         // Upcast from general node to PerturbedSpineNode
  //         PerturbedSpineNode* perturbed_spine_node_pt =
  //           dynamic_cast<PerturbedSpineNode*>(this->node_pt(l));
  //
  //         // Calculate interpolated i-th component of perturbed spine
  //         "heights" interpolated_H +=
  //           perturbed_spine_node_pt->perturbed_spine_pt()->height(i) *
  //           psi[l];
  //       }
  //
  //       return (interpolated_H);
  //     }
  //   };


} // namespace oomph

#endif
